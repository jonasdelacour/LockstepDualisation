diff --git a/CMakeLists.txt b/CMakeLists.txt
index 41a3e93..72b5c30 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,7 +3,7 @@ cmake_minimum_required(VERSION 3.1)
 project(Fullerenes)
 
 set(CMAKE_CXX_STANDARD 17)
-set(FULLERENE_DATABASE_PATH ${CMAKE_SOURCE_DIR}/database/ CACHE PATH "Path to fullerene database root")
+set(FULLERENE_DATABASE_PATH ${CMAKE_CURRENT_LIST_DIR}/database/ CACHE PATH "Path to fullerene database root")
 set(FORTRAN_NMAX 5000 CACHE STRING "Maximum vertex count for Fortran routines using statically allocated memory")
 
 set(BLA_VENDOR Intel10_64lp_seq)
@@ -16,7 +16,7 @@ check_language(CUDA)
 # Get the current working branch
 execute_process(
   COMMAND git rev-parse --abbrev-ref HEAD
-  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+  WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
   OUTPUT_VARIABLE GIT_BRANCH
   OUTPUT_STRIP_TRAILING_WHITESPACE
 )
@@ -24,21 +24,21 @@ execute_process(
 # Get the latest abbreviated commit hash of the working branch
 execute_process(
   COMMAND git log -1 --format=%h
-  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+  WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
   OUTPUT_VARIABLE GIT_COMMIT_HASH
   OUTPUT_STRIP_TRAILING_WHITESPACE
 )
 
 # C++ configure file
 configure_file(
-  ${CMAKE_SOURCE_DIR}/include/fullerenes/config.hh.in
+  ${CMAKE_CURRENT_LIST_DIR}/include/fullerenes/config.hh.in
   ${CMAKE_BINARY_DIR}/include/fullerenes/config.hh
   )
 
 # Fortran configure file
 configure_file(
-  ${CMAKE_SOURCE_DIR}/include/fullerenes/config.f.in
-  ${CMAKE_SOURCE_DIR}/src/fortran/config.f
+  ${CMAKE_CURRENT_LIST_DIR}/include/fullerenes/config.f.in
+  ${CMAKE_CURRENT_LIST_DIR}/src/fortran/config.f
 )
 
 
@@ -47,9 +47,9 @@ include_directories(${CMAKE_BINARY_DIR}/include/)
 
 
 # Fortran compiler flags
-set(CMAKE_Fortran_FLAGS "-fPIC -cpp -O3 -m64 -mcmodel=medium")
+set(CMAKE_Fortran_FLAGS "-fPIC -cpp -O3 -m64")
 # C++ compiler flags
-set(CMAKE_CXX_FLAGS "-std=c++1z -fPIC -O3 -m64 -pthread -I /opt/nvidia/hpc_sdk/Linux_x86_64/2022/cuda/11.8/include/")
+set(CMAKE_CXX_FLAGS "-std=c++1z -fPIC -O3 -m64 -pthread")
 
 add_subdirectory(src/c++)
 add_subdirectory(src/fortran)
@@ -69,7 +69,7 @@ if(CMAKE_CUDA_COMPILER)
 #NOTE: -gencode arch argument is EXTREMELY important to get right, the program will simply crash with a cudaError: invalid device function if the architecture does not match the GPU
 set(CMAKE_CUDA_FLAGS ${CMAKE_CUDA_FLAGS} "--std c++17 --use_fast_math --fmad true --ftz true --maxrregcount=80 -lineinfo -Xptxas -v --resource-usage -gencode arch=compute_86,code=sm_86  -I /opt/nvidia/hpc_sdk/Linux_x86_64/2022/cuda/11.8/include/ "
 )
-  
+
   add_subdirectory(src/cuda)
 endif()
 
diff --git a/include/fullerenes/auxiliary.hh b/include/fullerenes/auxiliary.hh
index 39a9c6d..f9bc456 100644
--- a/include/fullerenes/auxiliary.hh
+++ b/include/fullerenes/auxiliary.hh
@@ -32,15 +32,15 @@ struct edge_t : public pair<node_t,node_t> {
     first = u;
     second = index-u*(u-1)/2;
   }
-  inline size_t index() const { 
+  inline size_t index() const {
     const node_t v = first, u = second;
-    return u*(u-1)/2 + v; 
+    return u*(u-1)/2 + v;
   }
 };
 
 
 
-#define insert_unique(v,x) if(std::find(v.begin(),v.end(),x) == v.end()) v.push_back(x); 
+#define insert_unique(v,x) if(std::find(v.begin(),v.end(),x) == v.end()) v.push_back(x);
 
 template <typename S, typename T> ostream& operator<<(ostream& s, const pair<S,T>& p)
 {
@@ -204,15 +204,15 @@ template <typename T> vector< vector<T> > operator+(const vector< vector<T> >& x
 
 template <typename T> T sum(const vector<T>& xs)
 {
-  T sum = 0;
-  for(const auto &x: xs) sum += x;
-  return sum;
+  T tmp = 0;
+  for(const auto &x: xs) tmp += x;
+  return tmp;
 }
 
 template <typename T> T mean(const vector<T>& xs)
 {
-  T sum = sum(xs);
-  return sum/xs.size();
+  T tmp = sum(xs);
+  return tmp / xs.size();
 }
 
 template<typename T> void hash_combine(size_t &seed, T const &key) {
@@ -232,7 +232,7 @@ namespace std {
 
   template<typename IntType> struct hash<vector<IntType>> { // Vectors of integers smaller than 32 bit
     size_t operator()(const vector<IntType> &v) const {
-      return std::hash<u32string>()(u32string(v.begin(),v.end()));      
+      return std::hash<u32string>()(u32string(v.begin(),v.end()));
     }
   };
 
@@ -248,7 +248,7 @@ public:
   {
     for(size_t i=0;i<xs.size();i++) unordered_map<T,size_t>::insert({xs[i],i+start});
   }
-  
+
   size_t insert(const T& x){
     typename unordered_map<T,size_t>::const_iterator it(unordered_map<T,size_t>::find(x));
     if(it != this->end()) return it->second;
@@ -258,8 +258,8 @@ public:
       return nextid++;
     }
   }
-  
-  const T& invert(size_t idx) const { 
+
+  const T& invert(size_t idx) const {
     assert(idx>=0 && idx<nextid);
     return reverse[idx];
   }
@@ -300,7 +300,7 @@ public:
   bool   empty() const { return front_index==back_index; }
   size_t size()  const { return back_index-front_index;  }
   void   clear() const { front_index=back_index; }
-  
+
   const T& front(size_t offset=0) const {
     assert(!empty() && (offset<size()));
     return (*this)[front_index+offset];
@@ -309,7 +309,7 @@ public:
     assert(!empty() && (offset<size()));
     return (*this)[(back_index-1-offset+N)%N];
   }
-  
+
   T pop_front() {
     assert(!empty());
     T x((*this)[front_index]);
diff --git a/include/fullerenes/spiral.hh b/include/fullerenes/spiral.hh
index 975ac81..4c045db 100644
--- a/include/fullerenes/spiral.hh
+++ b/include/fullerenes/spiral.hh
@@ -1,5 +1,5 @@
 #pragma once
-#include <utility> 
+#include <utility>
 #include <vector>
 #include <string>
 #include <iostream>
@@ -29,12 +29,12 @@ struct general_spiral {
   {
     return jumps == s.jumps && spiral == s.spiral;
   }
-  
-  friend ostream &operator<<(ostream &s, const general_spiral &GS)
-  {
-    return s << make_pair(GS.jumps,GS.spiral); 
-  }
-  
+
+  //friend ostream &operator<<(ostream &s, const general_spiral &GS)
+  //{
+  //  return s << make_pair(GS.jumps,GS.spiral);
+  //}
+
 };
 
 // Make general spirals hashable
@@ -109,20 +109,20 @@ struct spiral_nomenclature {
 
   spiral_nomenclature(const string &str);
   spiral_nomenclature(const PlanarGraph &G, const naming_scheme_t name_type=CAGE,
-		      const construction_scheme_t construction_scheme=CS_NONE,		      
+		      const construction_scheme_t construction_scheme=CS_NONE,
 		      bool rarest_special_start = true);
 
   static string search_scheme_txt[4], construction_scheme_txt[4], naming_scheme_txt[4];
 
   string to_string(bool unpacked=false) const;
-  
+
   friend ostream& operator<<(ostream& s, const spiral_nomenclature &sn)
   {
     s << sn.to_string();
     return s;
   }
 
-  
+
 };
 
 
diff --git a/src/c++/CMakeLists.txt b/src/c++/CMakeLists.txt
index 79ae2c4..f0d5a4a 100644
--- a/src/c++/CMakeLists.txt
+++ b/src/c++/CMakeLists.txt
@@ -1,8 +1,21 @@
 add_library(fullerenes SHARED
-  graph.cc cubicgraph.cc planargraph.cc fullerenegraph.cc triangulation.cc polyhedron.cc spiralc.cc planargraph-io.cc polyhedron-io.cc
-  debug.cc fold.cc  unfold.cc geometryc.cc delaunay.cc  graph_fortran.cc isomerdb.cc layout.cc layout-optimise.cc
-  polyhedron-optimise.cc symmetry.cc eisenstein.cc ../contrib/mgmres.cc)
-
-target_link_libraries(fullerenes fortran_opt buckygen gfortran)
-
+  graph.cc
+  cubicgraph.cc
+  planargraph.cc
+  fullerenegraph.cc
+  triangulation.cc
+  polyhedron.cc
+  spiralc.cc
+  planargraph-io.cc
+  polyhedron-io.cc
+  fold.cc
+  unfold.cc
+  geometryc.cc
+  graph_fortran.cc
+  layout.cc
+  polyhedron-optimize.cc
+  eisenstein.cc
+  ../contrib/mgmres.cc
+)
 
+target_link_libraries(fullerenes buckygen fortran_opt gfortran)
diff --git a/src/contrib/buckygen-1.0/buckygen.c b/src/contrib/buckygen-1.0/buckygen.c
index 39c2789..1f8f48e 100644
--- a/src/contrib/buckygen-1.0/buckygen.c
+++ b/src/contrib/buckygen-1.0/buckygen.c
@@ -4,24 +4,24 @@ const char *SWITCHES="[-uagsh -IS#rq -odV -v]";
 /* buckygen.c :  generate fullerenes.
 
   This program generates fullerenes: triangulations where all vertices
-  have degree 5 or 6. Or if the dual representation is used: cubic plane 
-  graphs where all faces are pentagons or hexagons. Euler's formula 
+  have degree 5 or 6. Or if the dual representation is used: cubic plane
+  graphs where all faces are pentagons or hexagons. Euler's formula
   implies that a fullerene contains exactly 12 degree 5 vertices.
 
-  Buckygen can also generate IPR fullerenes efficiently, these 
-  are fullerenes which have no adjacent degree 5 vertices. 
+  Buckygen can also generate IPR fullerenes efficiently, these
+  are fullerenes which have no adjacent degree 5 vertices.
 
   Exact specifications and instructions for use can be found in the
   separate manual buckygen-guide.txt.
-  
+
   The latest version of buckygen can be found here:
   http://caagt.ugent.be/buckygen/
-  
+
   Author: Jan Goedgebeur (jan.goedgebeur@ugent.be)
-  In collaboration with: Gunnar Brinkmann (gunnar.brinkmann@ugent.be) 
+  In collaboration with: Gunnar Brinkmann (gunnar.brinkmann@ugent.be)
                          Brendan McKay (bdm@cs.anu.edu.au)
 
-  Buckygen uses the isomorphism rejection routines and switches from 
+  Buckygen uses the isomorphism rejection routines and switches from
   plantri 4.1. More information about plantri can be found here:
   http://cs.anu.edu.au/~bdm/plantri/
 
@@ -80,7 +80,7 @@ const char *SWITCHES="[-uagsh -IS#rq -odV -v]";
   The limits for ascii code could be raised to 114 and 59 easily.
   For connectivity < 3, there is also a limit on n of the number of
   bits in a long int (usually 32 or 64).
- 
+
 ---------
 
   Copyright (c) 2012 Ghent University
@@ -96,8 +96,8 @@ const char *SWITCHES="[-uagsh -IS#rq -odV -v]";
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
-  along with this program.  If not, see <http://www.gnu.org/licenses/>.  
- 
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
  ---------
 
   Change History:
@@ -149,9 +149,9 @@ extern int errno;
 #define MAXN 152            /* the maximum number of vertices; see above */
 #endif
 
- 
+
 /*
- * For modulo when splitting the generation into several parts. 
+ * For modulo when splitting the generation into several parts.
  * All fullerenes below this level are generated by all parts.
  * Increasing this level will make it more likely that the parts
  * have a more or less equal execution time.
@@ -210,13 +210,13 @@ typedef struct e /* The data type used for edges */
 
 /*
  * Extra bounding criterion for max pathlength in case of IPR.
- * 
+ *
  * If nv > LEVEL_THREE_INDEPENDENT, it first checks if there are 3 independent
  * short reductions. If that's the case, no long operations can destroy all of them.
- * 
+ *
  * If nv <= 70, only 2.48% has > 2 indep short reductions
  * If nv <= 130, 84% of them have > 2 such reductions
- * 
+ *
  * The default value (60) seems to be more or less optimal.
  */
 #define LEVEL_THREE_INDEPENDENT 60
@@ -224,8 +224,8 @@ typedef struct e /* The data type used for edges */
 
 /***********************Methods for splay-tree*****************************/
 
-/* 
- * Methods for the splay-tree (see splay.c for more information). 
+/*
+ * Methods for the splay-tree (see splay.c for more information).
  * Is used to make sure that no isomorphic irreducible ipr fullerenes
  * are generated.
  */
@@ -281,7 +281,7 @@ static FILE *outfile;      /* output file for graphs */
 static FILE *msgfile;      /* file for informational messages */
 
 /* Filenames for files where fullerenes without spirals are written to */
-#define MAX_FILENAME_LENGTH 200 
+#define MAX_FILENAME_LENGTH 200
 static char no_penta_spiral_filename[MAX_FILENAME_LENGTH];
 static char no_spiral_filename[MAX_FILENAME_LENGTH];
 
@@ -780,10 +780,10 @@ static int best_straight_colour_2 = 0;
 static EDGE *previous_rejector[MAXN+1];
 
 
-/* 
+/*
  * Global arrays with the possible bent exentsions.
  * These arrays aredynamically resized.
- * 
+ *
  * Is only used in case of IPR at the moment.
  */
 
@@ -835,7 +835,7 @@ is_in_degree_5_vertices_list(int vertex) {
 
 /*
  * Prints the current embedded graph to stdout.
- * 
+ *
  * Warning: contains some checks so it only works for fullerenes.
  */
 static void
@@ -899,7 +899,7 @@ void new_splaynode(SPLAYNODE *el, unsigned char *canong, int codelength, int typ
     el->length = codelength;
     el->type = type;
     *is_new_node = 1;
-    
+
     //fprintf(stderr, "New graph found. Nv: %d\n", nv);
     //fprintf(stderr, "Type is %d\n", type);
 }
@@ -923,7 +923,7 @@ int comparenodes(unsigned char *canong, int codelength, int type, SPLAYNODE *lis
     compare = codelength - list->length;
     if(compare == 0)
         compare = memcmp(canong, list->graph, codelength * sizeof(unsigned  char));
-    
+
     //Temp, for debugging only!
 /*
     if(compare == 0) {
@@ -1034,7 +1034,7 @@ restore_neighbour_invers(int v1, int added_vertex1, int v2, int added_vertex2) {
     //edge_list[vertex][old_neighbour]->end = org_neighbour;
     EDGE *e1 = edge_list[v1][added_vertex1];
     EDGE *e2 = edge_list[v2][added_vertex2];
-    
+
     e1->end = v2;
     e2->end = v1;
     e1->invers = e2;
@@ -1091,7 +1091,7 @@ insert_edge_fuller(int vertex, int new_neighbour, int after_neighbour) {
 /**************************************************************************/
 
 /*
- * Inserts a new edge clockwisely after the edge (vertex, after_neigbhour)  
+ * Inserts a new edge clockwisely after the edge (vertex, after_neigbhour)
  * and sets invers_edge as invers edge.
  */
 static void
@@ -1106,7 +1106,7 @@ insert_edge_fuller_invers(int vertex, int new_neighbour, int after_neighbour, ED
     DEBUGASSERT(degree[vertex] == 6);
     e->start = vertex;
     e->end = new_neighbour;
-    
+
     //Has to set, otherwise remove_edge() won't work
     edge_list[vertex][new_neighbour] = e;
     e->invers = invers_edge;
@@ -1216,7 +1216,7 @@ extend_L0(EDGE *startedge, int path[], int parallel_path[], int use_next)
     }
 
     //DEBUGASSERT(ne == (ne_old + 10));
-    
+
     if(use_next) {
         //nv
         e = firstedge[nv];
@@ -1273,7 +1273,7 @@ extend_L0(EDGE *startedge, int path[], int parallel_path[], int use_next)
 
     } else {
         //Identical, but using next instead of prev
-        
+
         //nv
         e = firstedge[nv];
         e->end = path[0];
@@ -1305,7 +1305,7 @@ extend_L0(EDGE *startedge, int path[], int parallel_path[], int use_next)
         e->end = nv;
         //edge_list[e->start][e->end] = e;
         e->invers = last_edge_L0;
-        last_edge_L0->invers = e;        
+        last_edge_L0->invers = e;
         e = e->next;
 
         e->end = path[1];
@@ -1365,11 +1365,11 @@ reduce_L0(int path[], int parallel_path[])
     restore_neighbour(parallel_path[1], nv, path[1]);
     restore_neighbour(parallel_path[1], nv + 1, path[2]);
 */
-    
+
     restore_neighbour_invers(path[1], nv, parallel_path[0], nv);
     restore_neighbour_invers(path[1], nv + 1, parallel_path[1], nv);
-    restore_neighbour_invers(path[2], nv + 1, parallel_path[1], nv + 1);        
-    
+    restore_neighbour_invers(path[2], nv + 1, parallel_path[1], nv + 1);
+
 /*
     //Update inverse edges and min
     set_inverse_edges(path[1], parallel_path[0]);
@@ -3525,7 +3525,7 @@ construct_canform_mirror(EDGE *givenedge, unsigned char code[])
         code++;
         temp = startedge[actual_number];  actual_number++;
     }
-    
+
 }
 
 /****************************************************************************/
@@ -3541,12 +3541,12 @@ static void
 testcanon_first_init_other(EDGE *givenedge, int representation[], int colour[])
 
 /* Tests whether starting from a given edge and constructing the code in
-   "->next" direction, an automorphism or even a better representation can 
-   be found. A better representation will be completely constructed and 
-   returned in "representation".  It works pretty similar to testcanon except 
+   "->next" direction, an automorphism or even a better representation can
+   be found. A better representation will be completely constructed and
+   returned in "representation".  It works pretty similar to testcanon except
    for obviously necessary changes, so for extensive comments see testcanon */ {
-    register EDGE *run;
-    register int vertex;
+    EDGE *run;
+    int vertex;
     EDGE *temp;
     EDGE * startedge[MAXN + 1];
     int number[MAXN], i;
@@ -3608,12 +3608,12 @@ static int
 testcanon_init_other(EDGE *givenedge, int representation[], int colour[])
 
 /* Tests whether starting from a given edge and constructing the code in
-   "->next" direction, an automorphism or even a better representation can 
-   be found. A better representation will be completely constructed and 
-   returned in "representation".  It works pretty similar to testcanon except 
+   "->next" direction, an automorphism or even a better representation can
+   be found. A better representation will be completely constructed and
+   returned in "representation".  It works pretty similar to testcanon except
    for obviously necessary changes, so for extensive comments see testcanon */ {
-    register EDGE *run;
-    register int col, vertex;
+    EDGE *run;
+    int col, vertex;
     EDGE *temp;
     EDGE * startedge[MAXN + 1];
     int number[MAXN], i;
@@ -3726,9 +3726,9 @@ static int
 testcanon_mirror_init_other(EDGE *givenedge, int representation[], int colour[])
 
 /* Tests whether starting from a given edge and constructing the code in
-   "->prev" direction, an automorphism or even a better representation can 
-   be found. A better representation will be completely constructed and 
-   returned in "representation".  It works pretty similar to testcanon except 
+   "->prev" direction, an automorphism or even a better representation can
+   be found. A better representation will be completely constructed and
+   returned in "representation".  It works pretty similar to testcanon except
    for obviously necessary changes, so for extensive comments see testcanon */ {
     EDGE *temp, *run;
     EDGE * startedge[MAXN + 1];
@@ -3841,26 +3841,26 @@ testcanon_mirror_init_other(EDGE *givenedge, int representation[], int colour[])
 /*
  * Computes the group of the current graph, even if it is not canonical.
  * This method is based on canon(), but uses a different canonical form.
- * 
- * Works OK if at least one vertex has valence >= 3. Otherwise some numberings 
- * are computed twice, since changing the orientation (the cyclic order around 
+ *
+ * Works OK if at least one vertex has valence >= 3. Otherwise some numberings
+ * are computed twice, since changing the orientation (the cyclic order around
  * each vertex) doesn't change anything .
  *
  * Does __NOT__ work for maps with loops, except in some special
  * cases (e.g.triangulations), but works for maps with double edges.
  *
- * Important: it is assumed that vertices with minimal colour have degree <= 5. 
+ * Important: it is assumed that vertices with minimal colour have degree <= 5.
  */
 static void
 compute_group(int colour[], EDGE *can_numberings[][MAXE],
         int *num_can_numberings, int *num_can_numberings_or_pres) {
     int i, j, test;
-    int minstart, maxend; /* (minstart,maxend) will be the chosen colour 
+    int minstart, maxend; /* (minstart,maxend) will be the chosen colour
 				 pair of an edge */
     EDGE * startlist[5 * MAXN], *run;
     int list_length;
     int representation[2 * MAXE + MAXN];
-    EDGE * numblist[MAXE], *numblist_mirror[MAXE]; /* lists of edges where 
+    EDGE * numblist[MAXE], *numblist_mirror[MAXE]; /* lists of edges where
 						starting gives a canonical representation */
     int numbs = 1, numbs_mirror = 0;
 
@@ -3928,7 +3928,7 @@ compute_group(int colour[], EDGE *can_numberings[][MAXE],
 
     *num_can_numberings_or_pres = numbs;
     *num_can_numberings = numbs + numbs_mirror;
-    
+
     if(*num_can_numberings > 1) {
         for(i = 0; i < numbs; i++)
             construct_numb(numblist[i], can_numberings[i]);
@@ -3938,7 +3938,7 @@ compute_group(int colour[], EDGE *can_numberings[][MAXE],
         if(numbs) can_numberings[0][0] = numblist[0];
         else can_numberings[0][0] = numblist_mirror[0];
     }
-    
+
 }
 
 /****************************************************************************/
@@ -3948,22 +3948,22 @@ canon_form(int colour[], EDGE *can_numberings[][MAXE],
         int *num_can_numberings, int *num_can_numberings_or_pres,
         unsigned char can_form[])
 
-/* Computes the canonical form of the global firstedge[] map 
+/* Computes the canonical form of the global firstedge[] map
    and writes it into can_form.
-   One of the criterions a canonical starting vertex must fulfill, 
-   is that its colour is minimal. 
-   A possible starting edge for the construction of a representation is 
+   One of the criterions a canonical starting vertex must fulfill,
+   is that its colour is minimal.
+   A possible starting edge for the construction of a representation is
    one with lexicographically minimal colour pair (start,INT_MAX-end).
 
-   For information about can_numberings, see canon(). 
-  
-   Works OK if at least one vertex has valence >= 3. Otherwise some numberings 
-   are computed twice, since changing the orientation (the cyclic order around 
-   each vertex) doesn't change anything 
+   For information about can_numberings, see canon().
+
+   Works OK if at least one vertex has valence >= 3. Otherwise some numberings
+   are computed twice, since changing the orientation (the cyclic order around
+   each vertex) doesn't change anything
 
    Does __NOT__ work for maps with loops, except in some special
    cases (e.g.triangulations), but works for maps with double edges.
- 
+
    Important: it is assumed that vertices with minimal colour have degree <= 5.
 
  */
@@ -3971,7 +3971,7 @@ canon_form(int colour[], EDGE *can_numberings[][MAXE],
     compute_group(colour, can_numberings, num_can_numberings, num_can_numberings_or_pres);
 
     //Important: it is assumed that the or pres automorphisms appear first in can_numberings.
-    
+
     if(*num_can_numberings_or_pres > 0)
         construct_canform(can_numberings[0][0], can_form);
     else
@@ -4197,11 +4197,11 @@ canon_edge_oriented(EDGE *edgelist_or[], int num_edges_or, int can_edges_or,
 
 /*
  * This method is similar to canon_edge_oriented but only performs a short scan.
- * 
+ *
  * Returns 0 if none of the first can_edges_or edges of edgelist_or is canonical
  * and none of the first can_edges_inv edges of edgelist_inv is canonical,
  * else returns 1.
- * 
+ *
  * If 1 is returned edgelist_canon_or and edgelist_canon_inv contain the edges
  * which have minimal representation. The first can_edges_canon_or and
  * can_edges_canon_inv edges in the list are the can_edges which have mimimal
@@ -4335,8 +4335,8 @@ numedgeorbits(int nbtot, int nbop)
 /* return number of orbits of directed edges, under the
    orientation-preserving automorphism group (assumed computed) */
 {
-    register EDGE **nb0,**nblim,**nb;
-    register int i,j;
+    EDGE **nb0,**nblim,**nb;
+    int i,j;
 
     if (nbtot == 1)
         return ne;
@@ -4575,9 +4575,9 @@ numorbitsonface(int nbtot, int nbop, EDGE *e)
    the left of edge e, under the orientation-preserving
    automorphism group (assumed computed) */
 {
-    register EDGE **nb0,**nblim,**nb;
-    register EDGE *e1;
-    register int i,j;
+    EDGE **nb0,**nblim,**nb;
+    EDGE *e1;
+    int i,j;
 
     RESETMARKS;
 
@@ -4621,7 +4621,7 @@ initialize_fuller_code(unsigned char code[], int code_length)
 {
     int i;
     EDGE *e, *elast, *ee, *eelast;
-    
+
     FREE_EDGES;
 
     nv = code[0];
@@ -4702,7 +4702,7 @@ initialize_fuller_code(unsigned char code[], int code_length)
 
     straight_length = MAX_STRAIGHT_LENGTH + 1;
     num_bent_zero_extensions = 0;
-    
+
     for(i = 0; i <= maxnv; i++)
         previous_rejector[i] = NULL;
 
@@ -4742,7 +4742,7 @@ initialize_fuller_arrays(void)
             /*
              * Remark: better bound should be possible for even distances.
              * Could even use experimental results.
-             * 
+             *
              * Important: it is assumed by determine_max_pathlength_straight()
              * that distance is monotonically increasing and that the difference
              * in distance is at most 1.
@@ -4781,7 +4781,7 @@ initialize_fuller_arrays(void)
             fprintf(stderr, "Error: distance can be at most %d\n", MAX_STRAIGHT_LENGTH - 1);
             fprintf(stderr, "Increase MAX_STRAIGHT_LENGTH in order to continue...\n");
             exit(1);
-        }        
+        }
     }
 
 /*
@@ -4794,7 +4794,7 @@ initialize_fuller_arrays(void)
 /**************************************************************************/
 
 /**
- * Returns 1 if the fullerene contains three L1 reductions which do not have 
+ * Returns 1 if the fullerene contains three L1 reductions which do not have
  * any common 5-vertices, else returns 0.
  * Important it is assumed that straight_length = 3.
  */
@@ -4815,11 +4815,11 @@ static int contains_three_indep_L1s() {
                             return 1;
                     }
                     UNMARK_V(straight_extensions[j][0]);
-                    UNMARK_V(straight_extensions[j][2]);                    
+                    UNMARK_V(straight_extensions[j][2]);
                 }
             }
             UNMARK_V(straight_extensions[i][0]);
-            UNMARK_V(straight_extensions[i][2]);            
+            UNMARK_V(straight_extensions[i][2]);
         }
     }
     return 0;
@@ -4828,7 +4828,7 @@ static int contains_three_indep_L1s() {
 /**************************************************************************/
 
 /**
- * Returns 1 if the fullerene contains three L1 reductions which do not have 
+ * Returns 1 if the fullerene contains three L1 reductions which do not have
  * any common 5-vertices, else returns 0.
  * Important it is assumed that straight_length = 3.
  */
@@ -4848,11 +4848,11 @@ static int contains_three_indep_B00s() {
                             return 1;
                     }
                     UNMARK_V(bent_zero_extensions[j][0]);
-                    UNMARK_V(bent_zero_extensions[j][3]);                    
+                    UNMARK_V(bent_zero_extensions[j][3]);
                 }
             }
             UNMARK_V(bent_zero_extensions[i][0]);
-            UNMARK_V(bent_zero_extensions[i][3]);            
+            UNMARK_V(bent_zero_extensions[i][3]);
         }
     }
     return 0;
@@ -4904,7 +4904,7 @@ determine_max_pathlength_straight() {
                 //DEBUGASSERT(!fulleriprswitch); //Since ipr fullerenes never have L0 reductions
                 max_pathlength = 3;
                 if(nv + max_pathlength == maxnv - 1 && !startswitch)
-                    max_pathlength--;                
+                    max_pathlength--;
             }
 
             if(max_pathlength > 4) {
@@ -4922,18 +4922,18 @@ determine_max_pathlength_straight() {
                     if(nv + max_pathlength == maxnv - 1 && !startswitch)
                         max_pathlength--;
                 }
-                
+
                 /*
                  * If G contains a reduction of length 3, al lgraphs obtained
-                 * from G have a reduction of length at most 5. 
+                 * from G have a reduction of length at most 5.
                  * Remark: this optimization will only help from nv=192, since
                  * in the other cases the length of the expansions is bounded.
                  */
-                if(max_pathlength > 5 && straight_length == 3 
+                if(max_pathlength > 5 && straight_length == 3
                         && num_straight_extensions > 0) {
                     max_pathlength = 5;
                     if(nv + max_pathlength == maxnv - 1 && !startswitch)
-                        max_pathlength--;                    
+                        max_pathlength--;
                 }
             }
         }
@@ -5078,7 +5078,7 @@ mark_edges_bent_zero(EDGE *e, int use_next, int numb_total, int npres) {
 /**************************************************************************/
 
 /*
- * Marks e for a bent expansion in the given direction and all edges which are 
+ * Marks e for a bent expansion in the given direction and all edges which are
  * equivalent with it.
  * Important: if numb_total > 1, it is assumed that edge->index is valid.
  */
@@ -5344,8 +5344,8 @@ might_destroy_previous_L0_extensions() {
 
 /*
  * Returns 1 if the current extension MIGHT destroy all shorter reductions, else
- * returns 0. 
- * 
+ * returns 0.
+ *
  * Important: it is assumed that this method is not called for B00 or L1.
  */
 static int
@@ -5377,16 +5377,16 @@ might_destroy_all_straight_or_bent_zero_reductions_ipr(int max_length, int max_l
 */
 
             /*
-             * If extension goes through bent_zero_extensions[i][2], it just 
+             * If extension goes through bent_zero_extensions[i][2], it just
              * turns the B00 into a L2 or B10. So if max_length <= 4, the current
              * extensions cant be canonical.
              * Remark: in fact max_length <= 3 if only using straights.
              */
             if(max_length <= 4 && ISMARKED_V(bent_zero_extensions[i][2]))
                 continue;
-            
+
             if(ISMARKED_V5(bent_zero_extensions[i][1]) || ISMARKED_V5(bent_zero_extensions[i][4]))
-                continue;            
+                continue;
 
 /*
             if(bent_zero_extensions[i][1] == hexagon1 || bent_zero_extensions[i][1] == hexagon2
@@ -5417,7 +5417,7 @@ might_destroy_all_straight_or_bent_zero_reductions_ipr(int max_length, int max_l
             }
             if(j == B10_SIZE)
                 return 0;
-        }        
+        }
     }
     return 1;
 }
@@ -5489,7 +5489,7 @@ find_L0_extensions_next(EDGE *startedge, EDGE *edge_ext_straight[],
             edge_ext_straight[*num_ext_straight] = startedge;
             ext_use_next[*num_ext_straight] = 1;
             (*num_ext_straight)++;
-        } 
+        }
 
         /*
          * If current expansion doesn't destroy the previously shortest
@@ -5573,7 +5573,7 @@ find_L0_extensions_prev(EDGE *startedge, EDGE *edge_ext_straight[],
             edge_ext_straight[*num_ext_straight] = startedge;
             ext_use_next[*num_ext_straight] = 0;
             (*num_ext_straight)++;
-        } 
+        }
 
         /*
          * If current expansion doesn't destroy the previously shortest
@@ -5622,10 +5622,10 @@ find_L1_extensions_next(EDGE *startedge, EDGE *edge_ext_straight[],
         MARKHI_V(e->end);
         MARK_V(e->prev->end);
         e = e->invers->next->next->next;
-        
+
         //Otherwise extended graph is not ipr
         if(fulleriprswitch && (degree[e->end] == 5 || degree[e->prev->end] == 5))
-            return;        
+            return;
 
         MARK_V(e->prev->end);
         MARKHI_V(e->end);
@@ -5705,7 +5705,7 @@ find_L1_extensions_prev(EDGE *startedge, EDGE *edge_ext_straight[],
         MARKHI_V(e->end);
         MARK_V(e->next->end);
         e = e->invers->prev->prev->prev;
-        
+
         //Otherwise extended graph is not ipr
         if(fulleriprswitch && (degree[e->end] == 5 || degree[e->next->end] == 5))
             return;
@@ -5763,7 +5763,7 @@ find_L1_extensions_prev(EDGE *startedge, EDGE *edge_ext_straight[],
  * It is assumed that startedge->begin has degree 5.
  * Marks edges which would yield the same expansion.
  *
- * Important: it is assumed that min_pathlength is at least 4, so 
+ * Important: it is assumed that min_pathlength is at least 4, so
  * this method won't return any L0 or L1 extensions.
  */
 static void
@@ -5792,7 +5792,7 @@ find_straight_extensions_next(EDGE *startedge, int min_pathlength, int max_pathl
                     e = startedge;
                     RESETMARKS_V;
                     if(fulleriprswitch)
-                        RESETMARKS_V5;  
+                        RESETMARKS_V5;
                     for(j = 0; j < i; j++) {
                         if(!ISMARKED_V(e->start)) MARKHI_V(e->start);
                         else return;
@@ -5812,29 +5812,29 @@ find_straight_extensions_next(EDGE *startedge, int min_pathlength, int max_pathl
                     if(!ISMARKED_V(e->end)) MARKHI_V(e->end);
                     else return;
                     if(ISMARKED_V(temp_vertex)) return;
-                    
+
                     if(fulleriprswitch) {
                         MARK_V5(e->start);
                         MARK_V5(e->prev->prev->end);
                     }
-                    
+
                     can_be_canonical = 1;
 
                     //Test if it destroys previous canonical extension
                     MARKHI_V(temp_vertex);
-                    
+
                     if(!fulleriprswitch)
                         can_be_canonical = might_destroy_previous_straight_extension(startedge->end, e->end, i - 1);
                     else
                         can_be_canonical = might_destroy_all_straight_or_bent_zero_reductions_ipr(i - 1, i - 1, startedge->start, temp_vertex);
-                    
+
                     if(can_be_canonical) {
                         edge_ext_straight[*num_ext_straight] = startedge;
                         ext_straight_length[*num_ext_straight] = i;
                         ext_use_next[*num_ext_straight] = 1;
                         (*num_ext_straight)++;
                     }
-                        
+
                     /*
                      * If current expansion doesn't destroy the previously shortest
                      * reductions, the reverse or another equivqlent expansion
@@ -5854,7 +5854,7 @@ find_straight_extensions_next(EDGE *startedge, int min_pathlength, int max_pathl
         e = e->invers->next->next->next;
         //Otherwise extended graph is not ipr
         if(fulleriprswitch && i == 1 && degree[e->prev->end] == 5)
-            return;        
+            return;
     }
 }
 
@@ -5866,7 +5866,7 @@ find_straight_extensions_next(EDGE *startedge, int min_pathlength, int max_pathl
  * It is assumed that startedge->begin has degree 5.
  * Marks edges which would yield the same expansion.
  *
- * Important: it is assumed that min_pathlength is at least 4, so 
+ * Important: it is assumed that min_pathlength is at least 4, so
  * this method won't return any L0 or L1 extensions.
  */
 static void
@@ -5896,7 +5896,7 @@ find_straight_extensions_prev(EDGE *startedge, int min_pathlength, int max_pathl
                     e = startedge;
                     RESETMARKS_V;
                     if(fulleriprswitch)
-                        RESETMARKS_V5;                      
+                        RESETMARKS_V5;
                     for(j = 0; j < i; j++) {
                         if(!ISMARKED_V(e->start)) MARKHI_V(e->start);
                         else return;
@@ -5907,7 +5907,7 @@ find_straight_extensions_prev(EDGE *startedge, int min_pathlength, int max_pathl
                         if(fulleriprswitch && j == 1) {
                             MARK_V5(e->next->end);
                             MARK_V5(e->end);
-                        }                        
+                        }
 
                         if(j < i - 1) {
                             e = e->invers->prev->prev->prev;
@@ -5916,11 +5916,11 @@ find_straight_extensions_prev(EDGE *startedge, int min_pathlength, int max_pathl
                     if(!ISMARKED_V(e->end)) MARKHI_V(e->end);
                     else return;
                     if(ISMARKED_V(temp_vertex)) return;
-                    
+
                     if(fulleriprswitch) {
                         MARK_V5(e->start);
                         MARK_V5(e->next->next->end);
-                    }                    
+                    }
 
                     can_be_canonical = 1;
 
@@ -5971,7 +5971,7 @@ find_straight_extensions_prev(EDGE *startedge, int min_pathlength, int max_pathl
  *
  * Important: B10 has higher priority than L3, so only check if the current bent
  * expansion MIGHT destroy all L0, L1 and L2 expansions.
- * 
+ *
  * Remark: actually not all straight reductions are tested. E.g. if
  * there is an L0, it is not tested if the bent also destroys all L1 reductions etc.
  */
@@ -6091,10 +6091,10 @@ find_bent_zero_extensions_prev(EDGE *startedge, EDGE *ext_bent_zero[],
          */
         EDGE *e = startedge;
         DEBUGASSERT(degree[e->start] == 5);
-        
+
         //Otherwise extended graph is not ipr
         if(fulleriprswitch && degree[e->invers->prev->prev->end] == 5)
-            return;        
+            return;
 
         e = e->invers->prev->prev->prev;
 
@@ -6132,7 +6132,7 @@ find_bent_zero_extensions_prev(EDGE *startedge, EDGE *ext_bent_zero[],
         mark_edges_bent_zero(e->invers, 1, numb_total, npres);
 
         //Must destroy all L0 and L1 reductions
-        if(fulleriprswitch || bent_might_destroy_all_straight_reductions(3)) {            
+        if(fulleriprswitch || bent_might_destroy_all_straight_reductions(3)) {
             ext_bent_zero[*num_ext_bent_zero] = startedge;
             ext_bent_zero_use_next[*num_ext_bent_zero] = 0;
             (*num_ext_bent_zero)++;
@@ -6145,7 +6145,7 @@ find_bent_zero_extensions_prev(EDGE *startedge, EDGE *ext_bent_zero[],
 /*
  * Searches all B00 extensions starting from startedge and direction prev.
  * It is assumed that startedge->begin has degree 5.
- * 
+ *
  * Important: does NOT mark edges which would yield the same expansion.
  * It is assumed that this method is only called for direction prev, so
  * the endedge does not have to be marked (that one will have direction next).
@@ -6153,7 +6153,7 @@ find_bent_zero_extensions_prev(EDGE *startedge, EDGE *ext_bent_zero[],
 static void
 find_bent_zero_extensions_prev_dont_mark_equivalent_expansions(EDGE *startedge, EDGE *ext_bent_zero[],
         int *num_ext_bent_zero, int ext_bent_zero_use_next[], int numb_total, int npres) {
-    
+
     //if(!ISMARKED_B00_PREV(startedge->label)) {
 
         /*
@@ -6163,10 +6163,10 @@ find_bent_zero_extensions_prev_dont_mark_equivalent_expansions(EDGE *startedge,
          */
         EDGE *e = startedge;
         DEBUGASSERT(degree[e->start] == 5);
-        
+
         //Otherwise extended graph is not ipr
         if(fulleriprswitch && degree[e->invers->prev->prev->end] == 5)
-            return;        
+            return;
 
         e = e->invers->prev->prev->prev;
 
@@ -6222,7 +6222,7 @@ static void
 add_bent_extension(EDGE *startedge, int bent_position, int bent_length, int use_next) {
     if(num_ext_bent_global == max_num_ext_bent_global) {
         //Array is full, so make a bigger array...
-        
+
         DEBUGASSERT(num_ext_bent_global > 0);
         //+1 to avoid arrays of size 0
         EDGE * ext_bent[num_ext_bent_global];
@@ -6233,7 +6233,7 @@ add_bent_extension(EDGE *startedge, int bent_position, int bent_length, int use_
         memcpy(ext_bent_position, ext_bent_position_global, sizeof(int) * num_ext_bent_global);
         memcpy(ext_bent_length, ext_bent_length_global, sizeof(int) * num_ext_bent_global);
         memcpy(ext_bent_use_next, ext_bent_use_next_global, sizeof(int) * num_ext_bent_global);
-        
+
         free(ext_bent_global);
         free(ext_bent_position_global);
         free(ext_bent_length_global);
@@ -6261,14 +6261,14 @@ add_bent_extension(EDGE *startedge, int bent_position, int bent_length, int use_
         if(ext_bent_use_next_global == NULL) {
             fprintf(stderr, "Error: can't get enough memory\n");
             exit(1);
-        }   
-        
+        }
+
         memcpy(ext_bent_global, ext_bent, sizeof(EDGE *) * num_ext_bent_global);
         memcpy(ext_bent_position_global, ext_bent_position, sizeof(int) * num_ext_bent_global);
         memcpy(ext_bent_length_global, ext_bent_length, sizeof(int) * num_ext_bent_global);
-        memcpy(ext_bent_use_next_global, ext_bent_use_next, sizeof(int) * num_ext_bent_global);        
+        memcpy(ext_bent_use_next_global, ext_bent_use_next, sizeof(int) * num_ext_bent_global);
     }
-    
+
     ext_bent_global[num_ext_bent_global] = startedge;
     ext_bent_use_next_global[num_ext_bent_global] = use_next;
     ext_bent_position_global[num_ext_bent_global] = bent_position;
@@ -6282,7 +6282,7 @@ add_bent_extension(EDGE *startedge, int bent_position, int bent_length, int use_
  * Searches all bent extensions starting from startedge and direction next.
  * It is assumed that startedge->begin has degree 5.
  * Marks edges which would yield the same expansion.
- * 
+ *
  * Important: ext_bent[] is ignored in case of ipr, the expansions are stored
  * in ext_bent_global[] instead.
  */
@@ -6295,14 +6295,14 @@ find_bent_extensions_next(EDGE *startedge, int min_pathlength, int bent_position
     DEBUGASSERT(nv + max_length + 3 <= maxnv);
     DEBUGASSERT(startswitch || (nv + max_length + 3 != maxnv - 1 && (!fulleriprswitch || nv + max_length + 3 != maxnv - 2)));
     DEBUGASSERT(max_length >= min_pathlength);
-    
+
     EDGE *e = startedge;
     DEBUGASSERT(degree[e->start] == 5);
 
     RESETMARKS_V;
     MARK_V(e->start);
     MARK_V(e->end);
-    
+
     if(fulleriprswitch)
         RESETMARKS_V5;
 
@@ -6315,8 +6315,8 @@ find_bent_extensions_next(EDGE *startedge, int min_pathlength, int bent_position
                 return;
             MARK_V5(e->next->next->end);
             MARK_V5(e->next->next->next->end);
-        }        
-        
+        }
+
         if(ISMARKED_V(e->next->end)) return;
         else MARK_V(e->next->end);
         e = e->next->next->next;
@@ -6329,12 +6329,12 @@ find_bent_extensions_next(EDGE *startedge, int min_pathlength, int bent_position
     e = e->next->next;
     if(ISMARKED_V(e->end)) return;
     else MARK_V(e->end);
-    
+
     int (*proc_might_destroy_all_straights) (int, int, int, int) = NULL;
     if(!fulleriprswitch)
         proc_might_destroy_all_straights = bent_might_destroy_all_straight_reductions_dummy;
     else
-        proc_might_destroy_all_straights = might_destroy_all_straight_or_bent_zero_reductions_ipr;    
+        proc_might_destroy_all_straights = might_destroy_all_straight_or_bent_zero_reductions_ipr;
 
     for(i = bent_position; i <= max_length; i++) {
         e = e->invers;
@@ -6360,14 +6360,14 @@ find_bent_extensions_next(EDGE *startedge, int min_pathlength, int bent_position
 
                 /*
                  * Mark equivalent extensions.
-                 * 
+                 *
                  * Old:
                  * Let a := bent_position and b := i - bent_position.
                  * So this gives us expansion Bab. We only have to do the marking
                  * in case a == b. If a > b, the expansion Bba starting from the
                  * endedge in the other direction won't be accepted, so we don't
                  * have to mark it.
-                 * 
+                 *
                  * New:
                  * Expansions Bab with a < b are also allowed, because in case
                  *  of IPR the search is only done in one direction.
@@ -6405,7 +6405,7 @@ find_bent_extensions_next(EDGE *startedge, int min_pathlength, int bent_position
                 if(fulleriprswitch) {
                     UNMARK_V5(e->prev->prev->end);
                     UNMARK_V5(e->prev->prev->prev->end);
-                }                
+                }
 
             }
         }
@@ -6419,7 +6419,7 @@ find_bent_extensions_next(EDGE *startedge, int min_pathlength, int bent_position
  * Searches all bent extensions starting from startedge and direction prev.
  * It is assumed that startedge->begin has degree 5.
  * Marks edges which would yield the same expansion.
- * 
+ *
  * Important: ext_bent[] is ignored in case of ipr, the expansions are stored
  * in ext_bent_global[] instead.
  */
@@ -6439,7 +6439,7 @@ find_bent_extensions_prev(EDGE *startedge, int min_pathlength, int bent_position
     RESETMARKS_V;
     MARK_V(e->start);
     MARK_V(e->end);
-    
+
     if(fulleriprswitch)
         RESETMARKS_V5;
 
@@ -6451,9 +6451,9 @@ find_bent_extensions_prev(EDGE *startedge, int min_pathlength, int bent_position
             if(degree[e->prev->prev->end] == 5)
                 return;
             MARK_V5(e->prev->prev->end);
-            MARK_V5(e->prev->prev->prev->end);            
+            MARK_V5(e->prev->prev->prev->end);
         }
-        
+
         if(ISMARKED_V(e->prev->end)) return;
         else MARK_V(e->prev->end);
         e = e->prev->prev->prev;
@@ -6466,7 +6466,7 @@ find_bent_extensions_prev(EDGE *startedge, int min_pathlength, int bent_position
     e = e->prev->prev;
     if(ISMARKED_V(e->end)) return;
     else MARK_V(e->end);
-    
+
     int (*proc_might_destroy_all_straights) (int, int, int, int) = NULL;
     if(!fulleriprswitch)
         proc_might_destroy_all_straights = bent_might_destroy_all_straight_reductions_dummy;
@@ -6483,7 +6483,7 @@ find_bent_extensions_prev(EDGE *startedge, int min_pathlength, int bent_position
 
         if(i >= min_pathlength) {
             //Bent with length i adds i + 3 new vertices...
-            //if((nv + i + 3 != maxnv - 1 || startswitch) 
+            //if((nv + i + 3 != maxnv - 1 || startswitch)
             if((startswitch || (nv + i + 3 != maxnv - 1 && (!fulleriprswitch || nv + i + 3 != maxnv - 2)))
                     && degree[e->end] == 5
                     && !ISMARKED_BENT_PREV(startedge->label, bent_position, i)
@@ -6496,14 +6496,14 @@ find_bent_extensions_prev(EDGE *startedge, int min_pathlength, int bent_position
 
                 /*
                  * Mark equivalent extensions.
-                 * 
+                 *
                  * Old:
                  * Let a := bent_position and b := i - bent_position.
                  * So this gives us expansion Bab. We only have to do the marking
                  * in case a == b. If a > b, the expansion Bba starting from the
                  * endedge in the other direction won't be accepted, so we don't
                  * have to mark it.
-                 * 
+                 *
                  * New:
                  * Expansions Bab with a < b are also allowed, because in case
                  *  of IPR the search is only done in one direction.
@@ -6539,11 +6539,11 @@ find_bent_extensions_prev(EDGE *startedge, int min_pathlength, int bent_position
                     }
                 }
                 UNMARK_V(e->next->end);
-                
+
                 if(fulleriprswitch) {
                     UNMARK_V5(e->next->next->end);
                     UNMARK_V5(e->next->next->next->end);
-                }                
+                }
 
             }
         }
@@ -6554,7 +6554,7 @@ find_bent_extensions_prev(EDGE *startedge, int min_pathlength, int bent_position
 /**************************************************************************/
 
 /*
- * Searches all bent extensions starting from startedge and direction next, 
+ * Searches all bent extensions starting from startedge and direction next,
  * using the method of crossing paths.
  * It is assumed that startedge->start has degree 5.
  * Marks edges which would yield an equivalent expansion.
@@ -6567,28 +6567,28 @@ find_bent_extensions_crossing_paths_ipr_next(EDGE *startedge, int min_pathlength
     DEBUGASSERT(nv + max_length + 3 <= maxnv);
     DEBUGASSERT(startswitch || (nv + max_length + 3 != maxnv - 1 && (!fulleriprswitch || nv + max_length + 3 != maxnv - 2)));
     DEBUGASSERT(max_length >= min_pathlength);
-    
+
     EDGE *e = startedge;
     DEBUGASSERT(degree[e->start] == 5);
-    
+
     /*
      * Marks are just checked afterwards (i.e. if the path is selfinterecting).
      * This is not really a problem, since mostly the paths won't selfintersect,
      * unless if they are very long.
      */
-    
+
     int i, label_bent;
     for(i = 0; i <= max_length; i++) {
         e = e->invers;
         if(i == 0 && degree[e->next->next->end] == 5)
             return; //Can't be ipr
-        
+
         e = e->next->next->next;
-        
+
         if(!ISMARKED_BENT_CROSSING_NEXT(e->label))
             MARK_BENT_CROSSING_NEXT(e->label);
         UPDATE_MIN_DISTANCE_NEXT(e->label, i + 1);
-        
+
         label_bent = e->invers->next->next->invers->label;
         if(ISMARKED_BENT_CROSSING_PREV(label_bent)) {
             if(i + MIN_DISTANCE_PREV(label_bent) - 1 <= max_length) {
@@ -6616,28 +6616,28 @@ find_bent_extensions_crossing_paths_ipr_prev(EDGE *startedge, int min_pathlength
     DEBUGASSERT(nv + max_length + 3 <= maxnv);
     DEBUGASSERT(startswitch || (nv + max_length + 3 != maxnv - 1 && (!fulleriprswitch || nv + max_length + 3 != maxnv - 2)));
     DEBUGASSERT(max_length >= min_pathlength);
-    
+
     EDGE *e = startedge;
     DEBUGASSERT(degree[e->start] == 5);
-    
+
     /*
      * Marks are just checked afterwards (i.e. if the path is selfinterecting).
      * This is not really a problem, since mostly the paths won't selfintersect,
      * unless if they are very long.
      */
-    
+
     int i, label_bent;
     for(i = 0; i <= max_length; i++) {
         e = e->invers;
         if(i == 0 && degree[e->prev->prev->end] == 5)
             return; //Can't be ipr
-        
+
         e = e->prev->prev->prev;
-        
+
         if(!ISMARKED_BENT_CROSSING_PREV(e->label))
             MARK_BENT_CROSSING_PREV(e->label);
         UPDATE_MIN_DISTANCE_PREV(e->label, i + 1);
-        
+
         label_bent = e->invers->prev->prev->invers->label;
         if(ISMARKED_BENT_CROSSING_NEXT(label_bent)) {
             if(i + MIN_DISTANCE_NEXT(label_bent) - 1 <= max_length) {
@@ -6807,7 +6807,7 @@ find_extensions_fuller(int numb_total, int numb_pres, int max_pathlength_straigh
      */
     //B00 and L1 add 3 new faces
     int can_perform_L1_and_B00 = (nv + 3 < maxnv - 1 || nv + 3 == maxnv || startswitch) && max_pathlength_straight > 2 && L1_or_B00_can_destroy_all_L0s();
-    
+
     int can_perform_L0 = nv + 2 != maxnv - 1 || startswitch;
 
     //Marks for L0
@@ -6868,7 +6868,7 @@ find_extensions_fuller(int numb_total, int numb_pres, int max_pathlength_straigh
                     e = e->next;
                 }
             }
-            
+
             /*
              * Each non-IPR fullerene has an L0 or L1 reduction, except
              * if it contains a special cluster of six 5-vertices (i.e.
@@ -6949,13 +6949,13 @@ find_extensions_fuller(int numb_total, int numb_pres, int max_pathlength_straigh
                         find_straight_extensions_prev(e, 4, max_pathlength_straight, ext_straight,
                                 num_ext_straight, ext_straight_length, ext_straight_use_next, numb_total, 0);
                         find_straight_extensions_next(e, 4, max_pathlength_straight, ext_straight,
-                                num_ext_straight, ext_straight_length, ext_straight_use_next, numb_total, 0);                        
+                                num_ext_straight, ext_straight_length, ext_straight_use_next, numb_total, 0);
                         for(j = 0; j <= max_length_bent; j++) {
                             find_bent_extensions_prev(e, 1, j, max_length_bent, ext_bent,
                                     num_ext_bent, ext_bent_position, ext_bent_length, ext_bent_use_next, numb_total, 0);
                             find_bent_extensions_next(e, 1, j, max_length_bent, ext_bent,
                                     num_ext_bent, ext_bent_position, ext_bent_length, ext_bent_use_next, numb_total, 0);
-                        }                        
+                        }
                         e = e->next;
                     }
                 }
@@ -7014,7 +7014,7 @@ find_extensions_fuller(int numb_total, int numb_pres, int max_pathlength_straigh
                             find_L1_extensions_next(e, ext_L1,
                                 num_ext_L1, ext_L1_use_next, numb_total, npres);
 
-                        find_bent_zero_extensions_prev(e, ext_bent_zero, 
+                        find_bent_zero_extensions_prev(e, ext_bent_zero,
                                 num_ext_bent_zero, ext_bent_zero_use_next, numb_total, npres);
 
                         if(!or_same_edge_found)
@@ -7056,7 +7056,7 @@ find_extensions_fuller(int numb_total, int numb_pres, int max_pathlength_straigh
 static void
 mark_vertices_in_neighbourhood_bfs(int v1, int v2, int max_distance) {
     DEBUGASSERT(degree[v1] == 5 && degree[v2] == 5);
-    
+
     int distance[nv];
     int queue[nv];
     int queue_size = 0;
@@ -7064,16 +7064,16 @@ mark_vertices_in_neighbourhood_bfs(int v1, int v2, int max_distance) {
     queue[queue_size++] = v2;
     distance[v1] = 0;
     distance[v2] = 0;
-    
+
     RESETMARKS_V2;
     RESETMARKS_V3;
     MARK_V2(v1);
     MARK_V2(v2);
     MARK_V3(v1);
-    MARK_V3(v2);    
-    
+    MARK_V3(v2);
+
     DEBUGASSERT(max_distance > 0);
-    
+
     EDGE *e;
     int i = 0, j;
     while(i < queue_size) {
@@ -7092,7 +7092,7 @@ mark_vertices_in_neighbourhood_bfs(int v1, int v2, int max_distance) {
         }
         i++;
     }
-    
+
 }
 
 /**************************************************************************/
@@ -7104,7 +7104,7 @@ mark_vertices_in_neighbourhood_bfs(int v1, int v2, int max_distance) {
 static void
 mark_vertices_in_neighbourhood_bfs_v3(int v1, int v2, int max_distance) {
     DEBUGASSERT(degree[v1] == 5 && degree[v2] == 5);
-    
+
     int distance[nv];
     int queue[nv];
     int queue_size = 0;
@@ -7112,13 +7112,13 @@ mark_vertices_in_neighbourhood_bfs_v3(int v1, int v2, int max_distance) {
     queue[queue_size++] = v2;
     distance[v1] = 0;
     distance[v2] = 0;
-    
+
     RESETMARKS_V3;
     MARK_V3(v1);
-    MARK_V3(v2);    
-    
+    MARK_V3(v2);
+
     DEBUGASSERT(max_distance > 0);
-    
+
     EDGE *e;
     int i = 0, j;
     while(i < queue_size) {
@@ -7135,7 +7135,7 @@ mark_vertices_in_neighbourhood_bfs_v3(int v1, int v2, int max_distance) {
         }
         i++;
     }
-    
+
 }
 
 /**************************************************************************/
@@ -7147,7 +7147,7 @@ mark_vertices_in_neighbourhood_bfs_v3(int v1, int v2, int max_distance) {
 static void
 mark_vertices_in_neighbourhood_bfs_v4(int v1, int v2, int max_distance) {
     DEBUGASSERT(degree[v1] == 5 && degree[v2] == 5);
-    
+
     int distance[nv];
     int queue[nv];
     int queue_size = 0;
@@ -7155,13 +7155,13 @@ mark_vertices_in_neighbourhood_bfs_v4(int v1, int v2, int max_distance) {
     queue[queue_size++] = v2;
     distance[v1] = 0;
     distance[v2] = 0;
-    
+
     RESETMARKS_V4;
     MARK_V4(v1);
-    MARK_V4(v2);    
-    
+    MARK_V4(v2);
+
     DEBUGASSERT(max_distance > 0);
-    
+
     EDGE *e;
     int i = 0, j;
     while(i < queue_size) {
@@ -7178,7 +7178,7 @@ mark_vertices_in_neighbourhood_bfs_v4(int v1, int v2, int max_distance) {
         }
         i++;
     }
-    
+
 }
 
 /**************************************************************************/
@@ -7191,7 +7191,7 @@ mark_vertices_in_neighbourhood_bfs_v4(int v1, int v2, int max_distance) {
 static int
 only_hexagons_in_neighbourhood_L1(int v1, int v2, EDGE *L1_edge, int max_distance) {
     DEBUGASSERT(degree[v1] == 5 && degree[v2] == 5);
-    
+
     int distance[nv];
     int queue[nv];
     int queue_size = 0;
@@ -7199,17 +7199,17 @@ only_hexagons_in_neighbourhood_L1(int v1, int v2, EDGE *L1_edge, int max_distanc
     queue[queue_size++] = v2;
     distance[v1] = 0;
     distance[v2] = 0;
-    
+
     RESETMARKS_V;
     MARK_V(v1);
     MARK_V(v2);
-    
+
     //The following 2 vertices may also be 5-vertices. Any reduction after expansion will still be valid
     MARK_V(L1_edge->prev->invers->next->next->next->end);
     MARK_V(L1_edge->next->invers->next->next->next->end);
-    
+
     DEBUGASSERT(max_distance > 0);
-    
+
     EDGE *e;
     int i = 0, j;
     while(i < queue_size) {
@@ -7218,7 +7218,7 @@ only_hexagons_in_neighbourhood_L1(int v1, int v2, EDGE *L1_edge, int max_distanc
             if(!ISMARKED_V(e->end)) {
                 if(degree[e->end] == 5)
                     return 0;
-                
+
                 MARK_V(e->end);
                 if(distance[queue[i]] < max_distance - 1) {
                     queue[queue_size++] = e->end;
@@ -7229,9 +7229,9 @@ only_hexagons_in_neighbourhood_L1(int v1, int v2, EDGE *L1_edge, int max_distanc
         }
         i++;
     }
-    
+
     return 1;
-    
+
 }
 
 /**************************************************************************/
@@ -7244,7 +7244,7 @@ only_hexagons_in_neighbourhood_L1(int v1, int v2, EDGE *L1_edge, int max_distanc
 static int
 only_hexagons_in_neighbourhood_L2(int v1, int v2, EDGE *edge1, EDGE *edge2, int max_distance) {
     DEBUGASSERT(degree[v1] == 5 && degree[v2] == 5);
-    
+
     int distance[nv];
     int queue[nv];
     int queue_size = 0;
@@ -7252,24 +7252,24 @@ only_hexagons_in_neighbourhood_L2(int v1, int v2, EDGE *edge1, EDGE *edge2, int
     queue[queue_size++] = v2;
     distance[v1] = 0;
     distance[v2] = 0;
-    
+
     RESETMARKS_V;
     MARK_V(v1);
     MARK_V(v2);
-    
+
     //The following 2 vertices may also be 5-vertices. Any reduction after expansion will still be valid
     MARK_V(edge1->prev->invers->prev->prev->end);
     MARK_V(edge1->prev->invers->prev->prev->prev->end);
     MARK_V(edge1->next->invers->next->next->end);
     MARK_V(edge1->next->invers->next->next->next->end);
-    
+
     MARK_V(edge2->prev->invers->prev->prev->end);
     MARK_V(edge2->prev->invers->prev->prev->prev->end);
     MARK_V(edge2->next->invers->next->next->end);
-    MARK_V(edge2->next->invers->next->next->next->end);    
-    
+    MARK_V(edge2->next->invers->next->next->next->end);
+
     DEBUGASSERT(max_distance > 0);
-    
+
     EDGE *e;
     int i = 0, j;
     while(i < queue_size) {
@@ -7278,7 +7278,7 @@ only_hexagons_in_neighbourhood_L2(int v1, int v2, EDGE *edge1, EDGE *edge2, int
             if(!ISMARKED_V(e->end)) {
                 if(degree[e->end] == 5)
                     return 0;
-                
+
                 MARK_V(e->end);
                 if(distance[queue[i]] < max_distance - 1) {
                     queue[queue_size++] = e->end;
@@ -7289,15 +7289,15 @@ only_hexagons_in_neighbourhood_L2(int v1, int v2, EDGE *edge1, EDGE *edge2, int
         }
         i++;
     }
-    
+
     return 1;
-    
+
 }
 
 /**************************************************************************/
 
 /*
- * Marks the 6 vertices of the L1 at index L1_extension_index in 
+ * Marks the 6 vertices of the L1 at index L1_extension_index in
  * straight_extensions[] that have to remain hexagons with MARK_V4.
  */
 static void mark_vertices_of_L1(int L1_extension_index) {
@@ -7327,7 +7327,7 @@ static void mark_vertices_of_L1(int L1_extension_index) {
         for(i = 0; i < 3; i++) {
             MARK_V4(e->end);
             e = e->next;
-        }        
+        }
     }
 }
 
@@ -7355,7 +7355,7 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
     *num_ext_bent_zero = 0;
     *num_ext_straight = 0;
     *num_ext_bent = 0;
-    
+
     DEBUGASSERT(straight_length != 2);
 
     /*
@@ -7387,9 +7387,9 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
         RESETMARKS_BENT_PREV;
     }
     DEBUGASSERT(startswitch || (nv + max_length_bent != maxnv - 1 && nv + max_length_bent != maxnv - 2));
-    
+
     DEBUGASSERT(max_pathlength_straight >= 3);
-    
+
      /* code for trivial group */
 
     if (numb_total == 1)
@@ -7422,7 +7422,7 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
              * reductions which remain valid after a long expansion which just
              * crosses it.
              */
-            
+
             /*
              * Also apply this for max_pathlength_straight == 4 (i.e. L2 or B10),
              * since for such an extension which makes an L1 longer, the 5-vertices
@@ -7482,7 +7482,7 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
                         MARK_V4(bent_zero_extensions[j][i]);
                     }
                 }
-            } 
+            }
             if(!contains_two_independent_reductions &&
                     straight_length == 3 && num_straight_extensions > 0) {
                 for(j = 0; j < num_straight_extensions; j++) {
@@ -7510,7 +7510,7 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
                                 contains_two_independent_reductions = 1;
                                 vertex1_other = straight_extensions[independent_L1][0];
                                 vertex2_other = straight_extensions[independent_L1][2];
-                                
+
                                 break;
                             } else if(j == num_straight_extensions - 1) {
                                 if(max_pathlength_straight > 4)
@@ -7534,13 +7534,13 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
 
             if(contains_two_independent_reductions) {
                 /*
-                 * There are two independent B00 or L1 reductions, which will 
-                 * stay valid after expansions which just cross it. 
+                 * There are two independent B00 or L1 reductions, which will
+                 * stay valid after expansions which just cross it.
                  * So only expansions which start in the neighbourhood of one
                  * reduction and which end in the neighbourhood of the other
                  * reduction are accepted. This is done using the method of
                  * crossing paths.
-                 */                
+                 */
                 RESETMARKS_BENT_CROSSING_NEXT;
                 RESETMARKS_BENT_CROSSING_PREV;
                 RESETMARKS_L0_NEXT;
@@ -7555,12 +7555,12 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
                         find_bent_extensions_crossing_paths_ipr_prev(e, 1, max_length_bent, ext_bent,
                                 num_ext_bent, ext_bent_position, ext_bent_length, ext_bent_use_next, numb_total, 0);
                         find_bent_extensions_crossing_paths_ipr_next(e, 1, max_length_bent, ext_bent,
-                                num_ext_bent, ext_bent_position, ext_bent_length, ext_bent_use_next, numb_total, 0);                        
+                                num_ext_bent, ext_bent_position, ext_bent_length, ext_bent_use_next, numb_total, 0);
 
                         e = e->next;
                     }
                 }
-                
+
                 for(i = 0; i < 12; i++) {
                     if(ISMARKED_V3(degree_5_vertices[i]) && degree_5_vertices[i] != vertex1 &&
                             degree_5_vertices[i] != vertex2) {
@@ -7734,7 +7734,7 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
 
     else
     {
-        
+
         int npres = numb_pres == 0 ? numb_total : numb_pres;
         int or_same_edge_found, index;
 
@@ -7770,7 +7770,7 @@ find_extensions_fuller_ipr(int numb_total, int numb_pres, int max_pathlength_str
                             find_L1_extensions_next(e, ext_L1,
                                 num_ext_L1, ext_L1_use_next, numb_total, npres);
 
-                        find_bent_zero_extensions_prev(e, ext_bent_zero, 
+                        find_bent_zero_extensions_prev(e, ext_bent_zero,
                                 num_ext_bent_zero, ext_bent_zero_use_next, numb_total, npres);
 
                         if(!or_same_edge_found)
@@ -7813,8 +7813,8 @@ make_dual(void)
    of the face boundary, and the size of the face in facesize[i], for each i.
    Returns the number of faces. */
 {
-    register int i,nf,sz;
-    register EDGE *e,*ex,*ef,*efx;
+    int i,nf,sz;
+    EDGE *e,*ex,*ef,*efx;
 
     RESETMARKS;
 
@@ -7873,8 +7873,8 @@ compute_code(unsigned char code[])
    edge is numbered 1 and the end 2.
 */
 {
-    register EDGE *run;
-    register int vertex;
+    EDGE *run;
+    int vertex;
     EDGE *temp;
     EDGE *startedge[MAXN+1];
     int number[MAXN+1], i;
@@ -7941,8 +7941,8 @@ compute_code_mirror(unsigned char code[])
    end is numbered 0.
 */
 {
-    register EDGE *run;
-    register int vertex;
+    EDGE *run;
+    int vertex;
     EDGE *temp;
     EDGE *startedge[MAXN+1];
     int number[MAXN+1], i;
@@ -8001,7 +8001,7 @@ compute_dual_code(unsigned char code[])
 /* works like compute_code -- only for the dual */
 
 {
-    register EDGE *run, *run2;
+    EDGE *run, *run2;
     EDGE *temp;
     EDGE *startedge[MAXF+1];
     int number[MAXF+1], i;
@@ -8076,7 +8076,7 @@ compute_dual_code_mirror(unsigned char code[])
 /* works like compute_code_mirror -- only for the dual */
 
 {
-    register EDGE *run, *run2;
+    EDGE *run, *run2;
     EDGE *temp;
     EDGE *startedge[MAXF+1];
     int number[MAXF+1], i;
@@ -8151,7 +8151,7 @@ compute_dual_code_mirror(unsigned char code[])
  * Then the numbers of the vertices adjacent to the vertex numbered 1 are
  * given -- ended by a 0, and listed in clockwise orientation.
  * Then those adjacent to 2, ended by a 0, etc.
- * 
+ *
  * Remark: this method is used for debugging purposes only!
  */
 void compute_planar_code(unsigned char code[]) {
@@ -8284,8 +8284,8 @@ write_digits(FILE *f, int doflip)
    procedure uses the internal numbering of vertices and is
    intended for debugging purposes. */
 {
-    register int i,k;
-    register EDGE *ex,*e;
+    int i,k;
+    EDGE *ex,*e;
     unsigned char code[2*MAXN+2*MAXE+9];
     int nvsize;
     int w;
@@ -8466,7 +8466,7 @@ write_code_as_sparse6(FILE *f, unsigned char code[])
    goes not use any global variables and works to 255 vertices. */
 
 {
-    register unsigned char *pin,*pout;
+    unsigned char *pin,*pout;
     unsigned char s6[20+2*MAXE+2*MAXF];
     int n,nb,i,j,lastj,x,k,r,rr,topbit;
     int loopcount;
@@ -8610,7 +8610,7 @@ write_code_as_graph6(FILE *f, unsigned char code[])
 
 {
     unsigned char g6[20+MAXF*(MAXF-1)/12];
-    register unsigned char *pin,*pout;
+    unsigned char *pin,*pout;
     int n,nlen,bodylen,i,j,org;
     static unsigned char g6bit[] = {32,16,8,4,2,1};
 
@@ -8798,7 +8798,7 @@ has_unmarked_neighbour(EDGE *startedge, int use_next, EDGE **unmarked_neighbour)
         else
             e = e->prev;
     } while(e != startedge);
-    
+
     return 0;
 }
 
@@ -8853,10 +8853,10 @@ got_one(int nbtot, int nbop)
 #ifdef STATS
     int numroot;
 #endif
-    
+
     doflip = oswitch && (nbop == nbtot || nbop == 0);
     wt = doflip ? 2 : 1;
-    
+
     if (Vswitch)
     {
 	if (nbtot == 1 || (oswitch && nbop == 1))
@@ -8864,18 +8864,18 @@ got_one(int nbtot, int nbop)
 	    ADDBIG(nout_V,wt);
 	    return;
 	}
-    }    
+    }
 
 #ifdef FILTER
     if (!FILTER(nbtot,nbop,doflip)) return;
 #endif
 
     //number_of_graphs_generated[nv]++;
-    
+
     ADDBIG(nout[nv], 1);
     ADDBIG(totalout,1);
     if (oswitch) ADDBIG(totalout_op,wt);
-    
+
 #ifdef DONT_OUTPUT
     return;
 #endif
@@ -8921,7 +8921,7 @@ got_one(int nbtot, int nbop)
                 fclose(fil);
             }
         }
-        
+
         for(i = 0; i < nv && !spiral_found; i++)
             if(degree[i] == 6) {
                 e = firstedge[i];
@@ -8933,7 +8933,7 @@ got_one(int nbtot, int nbop)
                     e = e->next;
                 }
             }
-        
+
         if(!spiral_found) {
             number_without_spiral[nv]++;
 
@@ -8961,13 +8961,13 @@ got_one(int nbtot, int nbop)
                 fclose(fil);
             }
         }
-            
+
     }
 
 #ifdef STATS
     numroot = wt * numedgeorbits(nbtot, nbop);
     ADDBIG(numrooted[nv], numroot);
-    if (nbtot == 1) 
+    if (nbtot == 1)
         ADDBIG(ntriv[nv],wt);
 #endif
 
@@ -9018,7 +9018,7 @@ static int
 has_short_straight_reduction(EDGE *startedge, int pathlength_cur_best, EDGE **endedge,
         unsigned char *direction_bitvector) {
     EDGE *e = startedge;
-    
+
     /*
      * Remark: marks actually only necessary for longer reductions.
      */
@@ -9085,7 +9085,7 @@ has_short_straight_reduction(EDGE *startedge, int pathlength_cur_best, EDGE **en
  *
  * If 1 is returned endedge is the edge at the other pentagon of the straightpath
  * and direction_bitvector contains if a next and/or prev reductions are valid.
- * 
+ *
  * Remark 1: this method should only be called in case the last operation was an
  * L1-extension.
  * Remark 2: faces cannot be the same, since there is only one type of 4-cycle and
@@ -9095,9 +9095,9 @@ static int
 has_short_straight_reduction_L1(EDGE *startedge, int pathlength_cur_best, EDGE **endedge,
         unsigned char *direction_bitvector) {
     EDGE *e = startedge;
-    
+
     DEBUGASSERT(pathlength_cur_best == 3);
-    
+
     int length = 1;
     //Pathlength i means distance i-1 between 2 deg 5 vertices in the extended graph
     if(degree[e->end] != 5) {
@@ -9148,7 +9148,7 @@ has_short_straight_reduction_ipr(EDGE *startedge, int pathlength_cur_best, EDGE
         unsigned char *direction_bitvector) {
     EDGE *e = startedge;
     int v[pathlength_cur_best+1],w[pathlength_cur_best+1];
-    
+
     RESETMARKS_V;
 
     v[1] = e->prev->end;
@@ -9172,39 +9172,39 @@ has_short_straight_reduction_ipr(EDGE *startedge, int pathlength_cur_best, EDGE
 	e = e->invers->next->next->next;
         //Only necessary to check if length > 2, since IPR fullerenes do not contain 5-cycles (or shorter ones)
         if(length > 2) {
-            if (ISMARKED_V(e->start) || ISMARKED_V(e->prev->end) || ISMARKED_V(e->next->end)) 
+            if (ISMARKED_V(e->start) || ISMARKED_V(e->prev->end) || ISMARKED_V(e->next->end))
                 return 0;
         }
         MARK_V(e->start);
         MARK_V(e->prev->end);
         MARK_V(e->next->end);
-        
+
 /*
 	if (ISMARKED_V(e->start)) return 0; else MARK_V(e->start);
         if (ISMARKED_V(e->prev->end)) return 0; else MARK_V(e->prev->end);
         if (ISMARKED_V(e->next->end)) return 0; else MARK_V(e->next->end);
 */
         length++;
-        
+
 	v[length] = e->prev->end;
-	w[length] = e->next->end;        
+	w[length] = e->next->end;
     }
-    
+
     DEBUGASSERT(length < pathlength_cur_best);
 
     if(degree[e->end] == 5) {
         e = e->invers;
-        
+
         if(ISMARKED_V(e->start)) return 0;
         if(ISMARKED_V(e->prev->prev->end)) return 0;
         if(ISMARKED_V(e->next->next->end)) return 0;
-        
+
         int a, b, c, d, j;
         EDGE *ea, *eb, *ec, *ed;
 
         a = v[0];
         ea = startedge->prev->invers->next->invers;
-        
+
         length++;
         c = w[length] = e->prev->prev->end;
         ec = e->prev->invers->next->invers;
@@ -9213,7 +9213,7 @@ has_short_straight_reduction_ipr(EDGE *startedge, int pathlength_cur_best, EDGE
         int is_valid_reduction_a = 0;
         if(degree[a] == 6 && degree[c] == 6) {
             is_valid_reduction_a = 1;
-            
+
             //Has to go till 3!
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ea = ea->prev;
@@ -9223,8 +9223,8 @@ has_short_straight_reduction_ipr(EDGE *startedge, int pathlength_cur_best, EDGE
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ec = ec->prev;
                 //Remark: ec->end == a doesn't have to be checked anymore
-                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0; 
-                if(degree[ec->end] == 5) is_valid_reduction_a = 0; 
+                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0;
+                if(degree[ec->end] == 5) is_valid_reduction_a = 0;
             }
 
             for(j = 0; is_valid_reduction_a && j < length; ++j)
@@ -9240,13 +9240,13 @@ has_short_straight_reduction_ipr(EDGE *startedge, int pathlength_cur_best, EDGE
         //if(is_valid_reduction_a && length < pathlength_cur_best - 1) {
             return 2;
         }
-        
-        
+
+
         b = w[0];
-        eb = startedge->next->invers->prev->invers;   
+        eb = startedge->next->invers->prev->invers;
         d = v[length];
         ed = e->next->invers->prev->invers;
-        
+
         int is_valid_reduction_b = 0;
         if(degree[b] == 6 && degree[d] == 6) {
             is_valid_reduction_b = 1;
@@ -9269,11 +9269,11 @@ has_short_straight_reduction_ipr(EDGE *startedge, int pathlength_cur_best, EDGE
                 if(degree[v[j]] == 5 && degree[w[j]] == 5) is_valid_reduction_b = 0;
 
         }
-        
+
         if(is_valid_reduction_b && length < pathlength_cur_best) {
             return 2;
         }
-        
+
         DEBUGASSERT(length == pathlength_cur_best || (!is_valid_reduction_a && !is_valid_reduction_b));
         *direction_bitvector = 0;
         if(is_valid_reduction_a)
@@ -9303,8 +9303,8 @@ has_short_straight_reduction_ipr(EDGE *startedge, int pathlength_cur_best, EDGE
  *
  * If 1 is returned endedge is the edge at the other pentagon of the straightpath
  * and direction_bitvector contains if a next and/or prev reductions are valid.
- * 
- * Remark: no need to mark since faces cannot be the same: in IPR fullerenes 
+ *
+ * Remark: no need to mark since faces cannot be the same: in IPR fullerenes
  * there are no 5-cycles which lead to a valid L2 reduction.
  */
 static int
@@ -9312,9 +9312,9 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
         unsigned char *direction_bitvector) {
     EDGE *e = startedge;
     int v[pathlength_cur_best+1],w[pathlength_cur_best+1];
-    
+
     DEBUGASSERT(pathlength_cur_best == 4);
-    
+
     v[1] = e->prev->end;
     v[0] = e->prev->prev->end;
     w[1] = e->next->end;
@@ -9325,22 +9325,22 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
     {
 	e = e->invers->next->next->next;
         length++;
-        
+
 	v[length] = e->prev->end;
-	w[length] = e->next->end;        
+	w[length] = e->next->end;
     }
-    
+
     DEBUGASSERT(length < pathlength_cur_best);
 
     if(degree[e->end] == 5) {
         e = e->invers;
-        
+
         int a, b, c, d, j;
         EDGE *ea, *eb, *ec, *ed;
 
         a = v[0];
         ea = startedge->prev->invers->next->invers;
-        
+
         length++;
         c = w[length] = e->prev->prev->end;
         ec = e->prev->invers->next->invers;
@@ -9349,7 +9349,7 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
         int is_valid_reduction_a = 0;
         if(degree[a] == 6 && degree[c] == 6) {
             is_valid_reduction_a = 1;
-            
+
             //Has to go till 3!
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ea = ea->prev;
@@ -9359,8 +9359,8 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ec = ec->prev;
                 //Remark: ec->end == a doesn't have to be checked anymore
-                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0; 
-                if(degree[ec->end] == 5) is_valid_reduction_a = 0; 
+                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0;
+                if(degree[ec->end] == 5) is_valid_reduction_a = 0;
             }
 
             for(j = 0; is_valid_reduction_a && j < length; ++j)
@@ -9376,13 +9376,13 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
         //if(is_valid_reduction_a && length < pathlength_cur_best - 1) {
             return 2;
         }
-        
-        
+
+
         b = w[0];
-        eb = startedge->next->invers->prev->invers;   
+        eb = startedge->next->invers->prev->invers;
         d = v[length];
         ed = e->next->invers->prev->invers;
-        
+
         int is_valid_reduction_b = 0;
         if(degree[b] == 6 && degree[d] == 6) {
             is_valid_reduction_b = 1;
@@ -9405,11 +9405,11 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
                 if(degree[v[j]] == 5 && degree[w[j]] == 5) is_valid_reduction_b = 0;
 
         }
-        
+
         if(is_valid_reduction_b && length < pathlength_cur_best) {
             return 2;
         }
-        
+
         DEBUGASSERT(length == pathlength_cur_best || (!is_valid_reduction_a && !is_valid_reduction_b));
         *direction_bitvector = 0;
         if(is_valid_reduction_a)
@@ -9439,7 +9439,7 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
  *
  * If 1 is returned endedge is the edge at the other pentagon of the straightpath
  * and direction_bitvector contains if a next and/or prev reductions are valid.
- * 
+ *
  * Remark: this method should only be called in case the last operation was an
  * L1-extension.
  */
@@ -9447,7 +9447,7 @@ has_short_straight_reduction_L2_ipr(EDGE *startedge, int pathlength_cur_best, ED
 static int
 has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, EDGE **endedge,
         unsigned char *direction_bitvector) {
-    
+
     if(degree[startedge->invers->next->next->next->end] == 5) {
         EDGE *e = startedge;
         int v[4], w[4];
@@ -9467,8 +9467,8 @@ has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, ED
         length++;
         v[length] = e->prev->end;
         w[length] = e->next->end;
-        //}        
-        
+        //}
+
         e = e->invers;
 
         int a, b, c, d, j;
@@ -9476,17 +9476,17 @@ has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, ED
 
         a = startedge->prev->prev->end;
         ea = startedge->prev->invers->next->invers;
-        
+
         length++;
         c = w[length] = e->prev->prev->end;
         ec = e->prev->invers->next->invers;
         v[length] = e->next->next->end;
-        
-        
+
+
         int is_valid_reduction_a = 0;
         if(degree[a] == 6 && degree[c] == 6) {
             is_valid_reduction_a = 1;
-            
+
             //Has to go till 3!
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ea = ea->prev;
@@ -9496,8 +9496,8 @@ has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, ED
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ec = ec->prev;
                 //Remark: ec->end == a doesn't have to be checked anymore
-                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0; 
-                if(degree[ec->end] == 5) is_valid_reduction_a = 0;                 
+                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0;
+                if(degree[ec->end] == 5) is_valid_reduction_a = 0;
             }
 
             for(j = 0; is_valid_reduction_a && j < length; ++j)
@@ -9507,12 +9507,12 @@ has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, ED
                 if(degree[w[j]] == 5 && degree[v[j]] == 5) is_valid_reduction_a = 0;
 
         }
-        
+
         b = startedge->next->next->end;
-        eb = startedge->next->invers->prev->invers;   
+        eb = startedge->next->invers->prev->invers;
         d = v[length];
         ed = e->next->invers->prev->invers;
-        
+
         int is_valid_reduction_b = 0;
         if(degree[b] == 6 && degree[d] == 6) {
             is_valid_reduction_b = 1;
@@ -9525,7 +9525,7 @@ has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, ED
                 ed = ed->next;
                 //Remark: ed->end == b doesn't have to be checked anymore
                 //if(ed->end == b || degree[ed->end] == 5) is_valid_reduction_b = 0;
-                if(degree[ed->end] == 5) is_valid_reduction_b = 0;                
+                if(degree[ed->end] == 5) is_valid_reduction_b = 0;
             }
 
             for(j = 0; is_valid_reduction_b && j < length; ++j)
@@ -9534,9 +9534,9 @@ has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, ED
             for(j = 1; is_valid_reduction_b && j < length; ++j)
                 if(degree[v[j]] == 5 && degree[w[j]] == 5) is_valid_reduction_b = 0;
 
-        }        
-        
-        
+        }
+
+
         DEBUGASSERT(length == pathlength_cur_best);
         *direction_bitvector = 0;
         if(is_valid_reduction_a)
@@ -9561,10 +9561,10 @@ has_short_straight_reduction_L1_ipr(EDGE *startedge, int pathlength_cur_best, ED
  */
 static int
 has_short_straight_reduction_L1_ipr_modified(EDGE *startedge) {
-    
+
     if(degree[startedge->start] != 5)
         return 0;
-    
+
     if(degree[startedge->invers->next->next->next->end] == 5) {
         EDGE *e = startedge;
         int v[4], w[4];
@@ -9584,8 +9584,8 @@ has_short_straight_reduction_L1_ipr_modified(EDGE *startedge) {
         length++;
         v[length] = e->prev->end;
         w[length] = e->next->end;
-        //}        
-        
+        //}
+
         e = e->invers;
 
         int a, b, c, d, j;
@@ -9593,17 +9593,17 @@ has_short_straight_reduction_L1_ipr_modified(EDGE *startedge) {
 
         a = startedge->prev->prev->end;
         ea = startedge->prev->invers->next->invers;
-        
+
         length++;
         c = w[length] = e->prev->prev->end;
         ec = e->prev->invers->next->invers;
         v[length] = e->next->next->end;
-        
-        
+
+
         int is_valid_reduction_a = 0;
         if(degree[a] == 6 && degree[c] == 6) {
             is_valid_reduction_a = 1;
-            
+
             //Has to go till 3!
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ea = ea->prev;
@@ -9613,8 +9613,8 @@ has_short_straight_reduction_L1_ipr_modified(EDGE *startedge) {
             for(j = 0; is_valid_reduction_a && j < 3; ++j) {
                 ec = ec->prev;
                 //Remark: ec->end == a doesn't have to be checked anymore
-                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0; 
-                if(degree[ec->end] == 5) is_valid_reduction_a = 0;                 
+                //if(ec->end == a || degree[ec->end] == 5) is_valid_reduction_a = 0;
+                if(degree[ec->end] == 5) is_valid_reduction_a = 0;
             }
 
             for(j = 0; is_valid_reduction_a && j < length; ++j)
@@ -9624,12 +9624,12 @@ has_short_straight_reduction_L1_ipr_modified(EDGE *startedge) {
                 if(degree[w[j]] == 5 && degree[v[j]] == 5) is_valid_reduction_a = 0;
 
         }
-        
+
         b = startedge->next->next->end;
-        eb = startedge->next->invers->prev->invers;   
+        eb = startedge->next->invers->prev->invers;
         d = v[length];
         ed = e->next->invers->prev->invers;
-        
+
         int is_valid_reduction_b = 0;
         if(degree[b] == 6 && degree[d] == 6) {
             is_valid_reduction_b = 1;
@@ -9642,7 +9642,7 @@ has_short_straight_reduction_L1_ipr_modified(EDGE *startedge) {
                 ed = ed->next;
                 //Remark: ed->end == b doesn't have to be checked anymore
                 //if(ed->end == b || degree[ed->end] == 5) is_valid_reduction_b = 0;
-                if(degree[ed->end] == 5) is_valid_reduction_b = 0;                
+                if(degree[ed->end] == 5) is_valid_reduction_b = 0;
             }
 
             for(j = 0; is_valid_reduction_b && j < length; ++j)
@@ -9651,8 +9651,8 @@ has_short_straight_reduction_L1_ipr_modified(EDGE *startedge) {
             for(j = 1; is_valid_reduction_b && j < length; ++j)
                 if(degree[v[j]] == 5 && degree[w[j]] == 5) is_valid_reduction_b = 0;
 
-        }        
-        
+        }
+
         //DEBUGASSERT(length == pathlength_cur_best);
         if(is_valid_reduction_a || is_valid_reduction_b)
             return 1;
@@ -9736,7 +9736,7 @@ add_L2_extension_to_list(EDGE *edge, int length, int use_next) {
         L2_extensions[num_L2_extensions][i++] = edge->prev->prev->end;
     }
     num_L2_extensions++;
-    
+
     DEBUGASSERT(i == L2_SIZE);
 }
 
@@ -9760,10 +9760,10 @@ add_bent_zero_extension_to_list_ipr(EDGE *startedge, int use_next) {
         endvertex = startedge->prev->prev->invers->next->next->end;
     else
         endvertex = startedge->next->next->invers->prev->prev->end;
-    
+
     if(bent_zero_is_already_in_list(startedge->start, endvertex))
         return;
-    
+
     int index = 0, j;
     EDGE *e = startedge;
     bent_zero_extensions[num_bent_zero_extensions][index++] = e->start;
@@ -9823,8 +9823,8 @@ add_bent_zero_extension_to_list_ipr(EDGE *startedge, int use_next) {
     }
 
     DEBUGASSERT(index == BENT_ZERO_SIZE);
-    num_bent_zero_extensions++;    
-    
+    num_bent_zero_extensions++;
+
 }
 
 /****************************************************************************/
@@ -9866,8 +9866,8 @@ add_straight_colour_2_L0_extension_to_list(EDGE *edge1, EDGE *edge2) {
 /*
  * Searches L2 reductions in the current fullerene and saves them into
  * straight_colour_2_L0_extensions[].
- * 
- * Important: it is assumed that num_L2_extensions = 0 and that 
+ *
+ * Important: it is assumed that num_L2_extensions = 0 and that
  * MAX_PREV_EXTENSIONS > 0.
  */
 static void
@@ -9922,10 +9922,10 @@ are_adjacent(int x, int y)
 /**************************************************************************/
 
 /*
- * Returns 1 if there is a bent zero reduction to a smaller IPR fullerene 
+ * Returns 1 if there is a bent zero reduction to a smaller IPR fullerene
  * starting from startedge with direction use_next, else returns 0.
  * If 1 is returned, endedge contains the last edge of the reduction.
- * 
+ *
  * Important: it is assumed that the fullerene is IPR.
  */
 /*
@@ -9934,39 +9934,39 @@ are_adjacent(int x, int y)
 static int
 has_B10_reduction_ipr_endedge(EDGE *startedge, int use_next, EDGE **endedge) {
     DEBUGASSERT(degree[startedge->end] == 6);
-    
+
     int a, b;
     EDGE *ea, *eb;
-    
+
     EDGE *e = startedge;
     if(use_next) {
         e = e->prev->prev;
         DEBUGASSERT(degree[e->end] != 5);
-        
+
         e = e->invers->next->next->next;
         if(degree[e->end] == 5)
             return 0;
-        
+
         e = e->invers->next->next;
         if(degree[e->end] == 6)
             return 0;
 
         e = e->invers->prev->prev;
         DEBUGASSERT(degree[e->end] != 5);
-        
+
         a = e->end;
         ea = e->invers->prev;
-        
+
         b = startedge->end;
         eb = startedge->invers->next;
 
     } else {
         e = e->next->next;
         DEBUGASSERT(degree[e->end] != 5);
-        
+
         e = e->invers->prev->prev->prev;
         if(degree[e->end] == 5)
-            return 0;        
+            return 0;
 
         e = e->invers->prev->prev;
         if(degree[e->end] == 6)
@@ -9974,10 +9974,10 @@ has_B10_reduction_ipr_endedge(EDGE *startedge, int use_next, EDGE **endedge) {
 
         e = e->invers->next->next;
         DEBUGASSERT(degree[e->end] != 5);
-        
+
         b = e->end;
         eb = e->invers->next;
-        
+
         a = startedge->end;
         ea = startedge->invers->prev;
     }
@@ -9991,7 +9991,7 @@ has_B10_reduction_ipr_endedge(EDGE *startedge, int use_next, EDGE **endedge) {
             || degree[eb->next->next->next->end] == 5) return 0;
 
     *endedge = e;
-    return 1;    
+    return 1;
 
 }
 
@@ -10009,10 +10009,10 @@ add_B10_extension_to_list(EDGE *startedge, int use_next) {
     if(use_next) {
         e = e->prev->prev;
         bent_one_zero_extensions[num_B10_extensions][i++] = e->end;
-        
+
         e = e->invers->next->next->next;
         bent_one_zero_extensions[num_B10_extensions][i++] = e->end;
-        
+
         e = e->invers->next->next;
         bent_one_zero_extensions[num_B10_extensions][i++] = e->end;
 
@@ -10020,20 +10020,20 @@ add_B10_extension_to_list(EDGE *startedge, int use_next) {
     } else {
         e = e->next->next;
         bent_one_zero_extensions[num_B10_extensions][i++] = e->end;
-        
+
         e = e->invers->prev->prev->prev;
         bent_one_zero_extensions[num_B10_extensions][i++] = e->end;
-        
+
         e = e->invers->prev->prev;
         bent_one_zero_extensions[num_B10_extensions][i++] = e->end;
 
         e = e->invers->next->next;
-    }    
-    
+    }
+
     bent_one_zero_extensions[num_B10_extensions][i++] = startedge->end;
     bent_one_zero_extensions[num_B10_extensions][i++] = e->end;
     num_B10_extensions++;
-    
+
     DEBUGASSERT(i == B10_SIZE);
 }
 
@@ -10053,8 +10053,8 @@ static int B10_is_already_in_list(int p1, int p2) {
 /*
  * Searches B10 reductions in the current fullerene and saves them into
  * bent_one_zero_extensions[].
- * 
- * Important: it is assumed that num_B10_extensions = 0 and that 
+ *
+ * Important: it is assumed that num_B10_extensions = 0 and that
  * MAX_PREV_EXTENSIONS > 0.
  */
 static void
@@ -10088,12 +10088,12 @@ search_B10_reductions_ipr() {
  * Returns 1 if one of the first can_edges_next edges of good_next or one
  * of the first can_edges_prev edges of good_prev is canonical using
  * canon_edge_oriented_short, else returns 0.
- * 
+ *
  * If 1 is returned good_next[] contains a list of all "next"-edges which could
  * be canonical and good_prev[] of all such "prev"-edges.
- * 
+ *
  * Remark: it is assu,ed that good_next, good_prev, can_edges_next and
- * can_edges_prev are valid. 
+ * can_edges_prev are valid.
  */
 static int
 test_canon_edge_short(int num_good_next, int num_good_prev,
@@ -10106,7 +10106,7 @@ test_canon_edge_short(int num_good_next, int num_good_prev,
         return 1;
     } else {
         DEBUGASSERT(nv >= NV_CANON_SHORT);
-        
+
         EDGE *good_next_tmp[num_good_next];
         EDGE *good_prev_tmp[num_good_prev];
 
@@ -10120,7 +10120,7 @@ test_canon_edge_short(int num_good_next, int num_good_prev,
 
         return res;
     }
-    
+
 }
 
 /****************************************************************************/
@@ -10436,7 +10436,7 @@ is_best_L0_reduction(EDGE *test_edge1, EDGE *test_edge2, int use_next, EDGE *goo
 
 /*
  * Returns 1 if there is an L0 or L1 reduction starting from startedge, else returns 0.
- * 
+ *
  * Important: startedge->start is assumed to have degree 5.
  */
 static int
@@ -10461,7 +10461,7 @@ is_L0_or_L1_reduction(EDGE *startedge) {
 /*
  * Remark 1: Can never occur that faces are the same, so no need to mark.
  * This is because there is only one possible 4-cycle.
- * Remark 2: Searching in one direction is sufficient, since endedge is same 
+ * Remark 2: Searching in one direction is sufficient, since endedge is same
  * but in other direction. Using direction prev here.
  */
 static int
@@ -10491,24 +10491,24 @@ has_bent_zero_reduction(EDGE *startedge, EDGE **endedge) {
 /****************************************************************************/
 
 /*
- * Returns 1 if there is a bent zero reduction to a smaller IPR fullerene 
+ * Returns 1 if there is a bent zero reduction to a smaller IPR fullerene
  * starting from startedge with direction use_next, else returns 0.
  * If 1 is returned, endedge contains the last edge of the reduction.
- * 
+ *
  * Important: it is assumed that the fullerene is IPR.
  */
 /*
  * Remark 1: Can never occur that faces are the same, so no need to mark.
- * Remark 2: Searching in one direction is sufficient, since endedge is same 
+ * Remark 2: Searching in one direction is sufficient, since endedge is same
  * but in other direction. Using direction prev here.
  */
 static int
 has_bent_zero_reduction_ipr(EDGE *startedge, EDGE **endedge) {
     DEBUGASSERT(degree[startedge->end] == 6);
-    
+
     int a, b;
     EDGE *ea, *eb;
-    
+
     EDGE *e = startedge;
     e = e->next->next;
     DEBUGASSERT(degree[e->end] != 5);
@@ -10541,7 +10541,7 @@ has_bent_zero_reduction_ipr(EDGE *startedge, EDGE **endedge) {
         MARK_B00_NEXT(e->label);
 */
     *endedge = e;
-    return 1;    
+    return 1;
 
 }
 
@@ -10550,7 +10550,7 @@ has_bent_zero_reduction_ipr(EDGE *startedge, EDGE **endedge) {
 /*
  * Returns 1 if there is a B10 reduction starting from startedge with
  * direction use_next, else returns 0.
- * 
+ *
  * Important: it is assumed that the fullerene is IPR.
  * If a fullerene is IPR, then there is no need to mark, since no 5-cycles
  * can lead to a valid B10 reduction.
@@ -10617,10 +10617,10 @@ has_B10_reduction(EDGE *startedge, int use_next) {
 static int
 has_B10_reduction_ipr(EDGE *startedge, int use_next) {
     DEBUGASSERT(degree[startedge->end] == 6);
-    
+
     int a, b;
-    EDGE *ea, *eb;    
-    
+    EDGE *ea, *eb;
+
     EDGE *e = startedge;
     if(use_next) {
         e = e->prev->prev;
@@ -10636,13 +10636,13 @@ has_B10_reduction_ipr(EDGE *startedge, int use_next) {
 
         e = e->invers->prev->prev;
         DEBUGASSERT(degree[e->end] != 5);
-        
+
         a = e->end;
         ea = e->invers->prev;
-        
+
         b = startedge->end;
         eb = startedge->invers->next;
-        
+
     } else {
         e = e->next->next;
         DEBUGASSERT(degree[e->end] != 5);
@@ -10657,12 +10657,12 @@ has_B10_reduction_ipr(EDGE *startedge, int use_next) {
 
         e = e->invers->next->next;
         DEBUGASSERT(degree[e->end] != 5);
-        
+
         b = e->end;
         eb = e->invers->next;
-        
+
         a = startedge->end;
-        ea = startedge->invers->prev;        
+        ea = startedge->invers->prev;
     }
 
     /* Test if reduced graph is IPR */
@@ -10671,8 +10671,8 @@ has_B10_reduction_ipr(EDGE *startedge, int use_next) {
     if(degree[ea->prev->end] == 5 || degree[ea->prev->prev->end] == 5
             || degree[ea->prev->prev->prev->end] == 5) return 0;
     if(degree[eb->next->end] == 5 || degree[eb->next->next->end] == 5
-            || degree[eb->next->next->next->end] == 5) return 0;    
-    
+            || degree[eb->next->next->next->end] == 5) return 0;
+
     return 1;
 
 }
@@ -10715,7 +10715,7 @@ search_bent_zero_reductions_ipr() {
 static int
 is_best_bent_zero_reduction(EDGE *test_edge1, EDGE *test_edge2, int use_next,
             EDGE *good_next[], int *ngood_next, int *can_edges_next, EDGE *good_prev[], int *ngood_prev, int *can_edges_prev) {
-    
+
     DEBUGASSERT(!fulleriprswitch);
 
     /* First check if there are no L0 or L1 reductions */
@@ -10734,8 +10734,8 @@ is_best_bent_zero_reduction(EDGE *test_edge1, EDGE *test_edge2, int use_next,
     //Warning: When also saving in case of nonipr, nv has to be < maxnv - 1!
     if(nv < maxnv - 1) {
         num_bent_zero_extensions = 0;
-    }    
-    
+    }
+
     /* Compute first colour */
     EDGE *good_next_tmp[MAX_EXTENSIONS_SINGLE];
     EDGE *good_prev_tmp[MAX_EXTENSIONS_SINGLE];
@@ -10817,7 +10817,7 @@ is_best_bent_zero_reduction(EDGE *test_edge1, EDGE *test_edge2, int use_next,
                     //if(fulleriprswitch && nv < maxnv - 2 && num_bent_zero_extensions < MAX_PREV_EXTENSIONS - 1)
                     //    add_bent_zero_extension_to_list_ipr(e, 0);
                     if(nv < maxnv - 1 && num_bent_zero_extensions < MAX_PREV_EXTENSIONS - 1)
-                        add_bent_zero_extension_to_list_ipr(e, 0);                    
+                        add_bent_zero_extension_to_list_ipr(e, 0);
                 }
             }
             e = e->next;
@@ -10847,13 +10847,13 @@ is_best_bent_zero_reduction(EDGE *test_edge1, EDGE *test_edge2, int use_next,
 static int
 is_best_bent_zero_reduction_ipr(EDGE *test_edge1, EDGE *test_edge2, int use_next,
             EDGE *good_next[], int *ngood_next, int *can_edges_next, EDGE *good_prev[], int *ngood_prev, int *can_edges_prev) {
-    
+
     DEBUGASSERT(fulleriprswitch);
-    
+
     /* First check if there are no L0 or L1 reductions */
     EDGE *e, *tmp_edge;
     int i, j;
-    unsigned char tmp_bv;    
+    unsigned char tmp_bv;
     for(i = 0; i < 12; i++) {
         e = firstedge[degree_5_vertices[i]];
         for(j = 0; j < 5; j++) {
@@ -10870,7 +10870,7 @@ is_best_bent_zero_reduction_ipr(EDGE *test_edge1, EDGE *test_edge2, int use_next
     //Warning: When also saving in case of nonipr, nv has to be < maxnv - 1!
     if(nv < maxnv - 2) {
         num_bent_zero_extensions = 0;
-    }    
+    }
 
     /* Compute first colour */
     EDGE *good_next_tmp[MAX_EXTENSIONS_SINGLE];
@@ -10888,7 +10888,7 @@ is_best_bent_zero_reduction_ipr(EDGE *test_edge1, EDGE *test_edge2, int use_next
         //colour_testedge1 = get_colour_next_5(test_edge1->invers->next);
         //colour_testedge2 = get_colour_prev_5(test_edge2->invers->prev);
         colour_testedge1 = get_colour_next_3(test_edge1->invers->prev->prev->invers->prev->prev);
-        colour_testedge2 = get_colour_prev_3(test_edge2->invers->next->next->invers->next->next);        
+        colour_testedge2 = get_colour_prev_3(test_edge2->invers->next->next->invers->next->next);
         best_colour = MAX(colour_testedge1, colour_testedge2);
 
         //To make sure test_edge1 and test_edge2 don't appear twice in the same list
@@ -10899,7 +10899,7 @@ is_best_bent_zero_reduction_ipr(EDGE *test_edge1, EDGE *test_edge2, int use_next
         //colour_testedge2 = get_colour_next_5(test_edge2->invers->next);
         //colour_testedge1 = get_colour_prev_5(test_edge1->invers->prev);
         colour_testedge2 = get_colour_next_3(test_edge2->invers->prev->prev->invers->prev->prev);
-        colour_testedge1 = get_colour_prev_3(test_edge1->invers->next->next->invers->next->next);        
+        colour_testedge1 = get_colour_prev_3(test_edge1->invers->next->next->invers->next->next);
         best_colour = MAX(colour_testedge1, colour_testedge2);
 
         //MARK_B00_PREV(test_edge1->label);
@@ -11126,14 +11126,14 @@ has_short_bent_reduction_ipr(EDGE *startedge, int bent_position, int bent_length
     DEBUGASSERT(degree[startedge->end] == 6);
     DEBUGASSERT(bent_length > 0);
     DEBUGASSERT(bent_length <= 2*bent_position);
-    
+
     int a, b, bent_neighbour;
     EDGE *ea, *eb;
     int v1[MAXN/2],w1[MAXN/2],len1;
-    int v2[MAXN/2],w2[MAXN/2],len2;    
-    
+    int v2[MAXN/2],w2[MAXN/2],len2;
+
     len1 = 0;
-    
+
     //Mark part before bent with MARKS_V and part after bent with MARKS_V2
     RESETMARKS_V;
     MARK_V(startedge->start);
@@ -11147,7 +11147,7 @@ has_short_bent_reduction_ipr(EDGE *startedge, int bent_position, int bent_length
     } else {
         a = startedge->end;
         ea = startedge->invers->prev;
-        
+
         MARK_V(startedge->prev->end);
         startedge = startedge->next->next;
     }
@@ -11173,14 +11173,14 @@ has_short_bent_reduction_ipr(EDGE *startedge, int bent_position, int bent_length
             return bent_of_same_length_found;
         else
             MARK_V(startedge->next->end);
-        
+
         if(i > 0) {
             if(use_next) {
                 v1[len1] = startedge->prev->end;
                 w1[len1] = startedge->next->end;
             } else {
                 w1[len1] = startedge->prev->end;
-                v1[len1] = startedge->next->end;                
+                v1[len1] = startedge->next->end;
             }
             len1++;
         }
@@ -11245,10 +11245,10 @@ has_short_bent_reduction_ipr(EDGE *startedge, int bent_position, int bent_length
                 w2[len2] = e->next->end;
             } else {
                 w2[len2] = e->prev->end;
-                v2[len2] = e->next->end;                
+                v2[len2] = e->next->end;
             }
-            len2++;            
-            
+            len2++;
+
             e = e->invers->next->next->next;
         }
 
@@ -11262,7 +11262,7 @@ has_short_bent_reduction_ipr(EDGE *startedge, int bent_position, int bent_length
             DEBUGASSERT(degree[end_vertex] == 6);
             if(!ISMARKED_V(end_vertex) && !ISMARKED_V2(end_vertex)) {
                 //Check if is valid reduction to smaller ipr
-                
+
                 if(use_next) {
                     a = end_vertex;
                     ea = e->invers->prev->prev->invers->prev;
@@ -11276,8 +11276,8 @@ has_short_bent_reduction_ipr(EDGE *startedge, int bent_position, int bent_length
                 if(degree[ea->prev->end] == 5 || degree[ea->prev->prev->end] == 5
                         || degree[ea->prev->prev->prev->end] == 5) abort_ipr = 1;
                 if(degree[eb->next->end] == 5 || degree[eb->next->next->end] == 5
-                        || degree[eb->next->next->next->end] == 5) abort_ipr = 1;   
-                
+                        || degree[eb->next->next->next->end] == 5) abort_ipr = 1;
+
                 //if j <= 1, no need to check v's and w's
                 if(!abort_ipr && j > 1) {
                     int k;
@@ -11287,17 +11287,17 @@ has_short_bent_reduction_ipr(EDGE *startedge, int bent_position, int bent_length
                     for(k = 1; !abort_ipr && k < len1; k++)
                         if(degree[v1[k-1]] == 5 && degree[w1[k]] == 5)
                             abort_ipr = 1;
-                    
+
                     if(!abort_ipr)
                         abort_ipr = (degree[v1[len1 - 1]] == 5 && degree[bent_neighbour] == 5);
-                    
+
                     for(k = 0; !abort_ipr && k < len2; k++)
                         if(degree[v2[k]] == 5 && degree[w2[k]] == 5)
                             abort_ipr = 1;
                     for(k = 1; !abort_ipr && k < len2; k++)
                         if(degree[w2[k-1]] == 5 && degree[v2[k]] == 5) //w and v swapped!
-                            abort_ipr = 1;                    
-                    
+                            abort_ipr = 1;
+
                 }
 
                 if(!abort_ipr) {
@@ -11448,7 +11448,7 @@ hasStraightIPR(EDGE *e, int max_length)
         d = v[len] = e->next->next->end;
         ec = e->prev->invers->next->invers;
         ed = e->next->invers->prev->invers;
-        
+
         DEBUGASSERT(len <= max_length + 2);
 
         if(degree[a] == 6 && degree[c] == 6) {
@@ -11549,8 +11549,8 @@ hasStraightIPR_given(EDGE *edge, int max_length) {
  *
  * If 1 is returned good_next[] contains a list of all "next"-edges which could
  * be canonical and good_prev[] of all such "prev"-edges.
- * 
- * Important: this method is not called for B00 reductions, use 
+ *
+ * Important: this method is not called for B00 reductions, use
  * is_best_bent_zero_reduction() instead.
  */
 static int
@@ -11562,10 +11562,10 @@ is_best_bent_reduction(EDGE *test_edge1, EDGE *test_edge2, int bent_position, in
     DEBUGASSERT(bent_length > 0);
 
     //Priorities: Lx Bx Lx+1 Bx+1 etc.
-    if((!fulleriprswitch && has_straight(bent_length + 1)) 
+    if((!fulleriprswitch && has_straight(bent_length + 1))
             || (fulleriprswitch && has_straight_ipr(bent_length + 1)))
         return 0;
-    
+
     int (*proc_short_bent) (EDGE *, int, int, int) = NULL;
     if(fulleriprswitch)
         proc_short_bent = has_short_bent_reduction_ipr;
@@ -11577,7 +11577,7 @@ is_best_bent_reduction(EDGE *test_edge1, EDGE *test_edge2, int bent_position, in
     int num_good_next, num_good_prev;
     num_good_next = num_good_prev = 0;
     //int bents_have_same_len = (2*bent_position == bent_length);
-    
+
     //Choose the edge with the longest path as representative for the reduction
     int length_path_1 = bent_position;
     int length_path_2 = bent_length - bent_position;
@@ -11616,7 +11616,7 @@ is_best_bent_reduction(EDGE *test_edge1, EDGE *test_edge2, int bent_position, in
         for(j = 0; j < 5; j++) {
             if(degree[e->end] == 6) //Remark: this if is not necessary in case of ipr
                 /*
-                 * Has to search in both directions here, since it is assumed that 
+                 * Has to search in both directions here, since it is assumed that
                  * first bent is longest.
                  */
                 for(k = 0; k < 2; k++) {
@@ -11644,7 +11644,7 @@ is_best_bent_reduction(EDGE *test_edge1, EDGE *test_edge2, int bent_position, in
 
     *ngood_next = num_good_next;
     *ngood_prev = num_good_prev;
-    
+
     //Remark: using is_best_third_colour_bent() here is slower.
 
     return 1;
@@ -11701,7 +11701,7 @@ has_B00_reductions_ipr() {
 /*
  * Returns 1 if the current graph contains at least 1 B00 reduction,
  * else returns 0.
- * 
+ *
  * Important: this method assumes that the current graph is IPR!
  * (see has_B10_reduction() for more info).
  */
@@ -11813,7 +11813,7 @@ is_best_straight_reduction(EDGE *test_edge1, EDGE *test_edge2, int pathlength, i
             EDGE *good_next[], int *ngood_next, int *can_edges_next, EDGE *good_prev[], int *ngood_prev, int *can_edges_prev) {
 
     DEBUGASSERT(!fulleriprswitch);
-    
+
     /* Compute first colour */
     EDGE *good_next_tmp[MAX_EXTENSIONS_SINGLE];
     EDGE *good_prev_tmp[MAX_EXTENSIONS_SINGLE];
@@ -11941,13 +11941,13 @@ is_best_straight_reduction_ipr(EDGE *test_edge1, EDGE *test_edge2, int pathlengt
             EDGE *good_next[], int *ngood_next, int *can_edges_next, EDGE *good_prev[], int *ngood_prev, int *can_edges_prev) {
 
     DEBUGASSERT(fulleriprswitch);
-    
+
     /* Compute first colour */
     EDGE *good_next_tmp[MAX_EXTENSIONS_SINGLE];
     EDGE *good_prev_tmp[MAX_EXTENSIONS_SINGLE];
     int num_good_next_tmp, num_good_prev_tmp;
     num_good_next_tmp = num_good_prev_tmp = 0;
-    
+
     int colour_testedge1, colour_testedge2;
     int testedge1_is_best, testedge2_is_best;
     int best_colour;
@@ -11955,20 +11955,20 @@ is_best_straight_reduction_ipr(EDGE *test_edge1, EDGE *test_edge2, int pathlengt
         //colour_testedge1 = get_colour_next_5(test_edge1->next->next->invers->next);
         //colour_testedge2 = get_colour_next_5(test_edge2->next->next->invers->next);
         colour_testedge1 = get_colour_next_3(test_edge1->next->next->invers->next->next);
-        colour_testedge2 = get_colour_next_3(test_edge2->next->next->invers->next->next);        
+        colour_testedge2 = get_colour_next_3(test_edge2->next->next->invers->next->next);
         best_colour = MAX(colour_testedge1, colour_testedge2);
     } else {
         //colour_testedge1 = get_colour_prev_5(test_edge1->prev->prev->invers->prev);
         //colour_testedge2 = get_colour_prev_5(test_edge2->prev->prev->invers->prev);
         colour_testedge1 = get_colour_prev_3(test_edge1->prev->prev->invers->prev->prev);
-        colour_testedge2 = get_colour_prev_3(test_edge2->prev->prev->invers->prev->prev);        
+        colour_testedge2 = get_colour_prev_3(test_edge2->prev->prev->invers->prev->prev);
         best_colour = MAX(colour_testedge1, colour_testedge2);
     }
     testedge1_is_best = (colour_testedge1 == best_colour);
     testedge2_is_best = (colour_testedge2 == best_colour);
-    
+
     int colour_tmp;
-    
+
     if(nv < maxnv - 2) {
         num_straight_extensions = 0;
         //num_straight_colour_2_extensions = 0;
@@ -12256,8 +12256,8 @@ scansimple_fuller(int nbtot, int nbop)
                      * in edge_list which we didn't update yet.
                      */
                     update_edge_list_L0();
-                    
-                    add_straight_colour_2_L0_extension_to_list(edge_list[path[0]][nv - 2], edge_list[parallel_path[2]][nv - 1]);                    
+
+                    add_straight_colour_2_L0_extension_to_list(edge_list[path[0]][nv - 2], edge_list[parallel_path[2]][nv - 1]);
 
                 }
 
@@ -12294,7 +12294,7 @@ scansimple_fuller(int nbtot, int nbop)
                 test_canon = 0;
                 xnbtot = xnbop = 1;
             }
-            
+
             if(!test_canon || canon_edge_oriented(good_edges_next, num_good_next, can_edges_next,
                     good_edges_prev, num_good_prev, can_edges_prev, degree, numbering, &xnbtot, &xnbop)) {
                 if(nv < maxnv - 1) {
@@ -12372,7 +12372,7 @@ scansimple_fuller(int nbtot, int nbop)
                     //num_bent_zero_extensions = 0;
                     add_bent_zero_extension_to_list_ipr(edge_list[nv - 3][path_b00[0]], ext_bent_zero_use_next[i]);
                 }
-                
+
                 scansimple_fuller(xnbtot, xnbop);
             }
 
@@ -12406,7 +12406,7 @@ scansimple_fuller(int nbtot, int nbop)
                 test_canon = 0;
                 xnbtot = xnbop = 1;
             }
-            
+
             if(!test_canon || canon_edge_oriented(good_edges_next, num_good_next, can_edges_next,
                     good_edges_prev, num_good_prev, can_edges_prev, degree, numbering, &xnbtot, &xnbop)) {
                 if(nv < maxnv - 1) {
@@ -12488,12 +12488,12 @@ scansimple_fuller(int nbtot, int nbop)
         if(is_best_bent_reduction(edge_list[nv - ext_bent_length[i] - 3][path_bent[0]], edge_list[nv - 1][path_bent[ext_bent_length[i] + 4]],
                 ext_bent_position[i], ext_bent_length[i], ext_bent_use_next[i],
                 good_edges_next, &num_good_next, &can_edges_next, good_edges_prev, &num_good_prev, &can_edges_prev)) {
-            test_canon = 1;            
+            test_canon = 1;
             if(num_good_next + num_good_prev == 1) {
                 test_canon = 0;
                 xnbtot = xnbop = 1;
             }
-            
+
             if(!test_canon || canon_edge_oriented(good_edges_next, num_good_next, can_edges_next,
                     good_edges_prev, num_good_prev, can_edges_prev, degree, numbering, &xnbtot, &xnbop)) {
                 if(nv < maxnv - 1) {
@@ -12517,11 +12517,11 @@ scansimple_fuller(int nbtot, int nbop)
  * Returns 1 if the current graph contains at least three independent short
  * ipr reductions. Two reductions are independent if the pentagons of both
  * reductions are on distance > 3.
- * 
+ *
  * Short reductions are: L1, B00, L2 and B10.
- * 
+ *
  * If 1 is returned, *max_pathlength_straight is also set.
- * If there are three independent L1 or B00 reductions, max_pathlength_straight 
+ * If there are three independent L1 or B00 reductions, max_pathlength_straight
  * is set to 3, else it is 4.
  */
 static int
@@ -12561,7 +12561,7 @@ contains_at_least_three_independent_short_reductions(int *max_pathlength_straigh
         is_short_reduction[num_short_reductions] = 0;
         num_short_reductions++;
     }
-        
+
     DEBUGASSERT(num_short_reductions <= num_bent_zero_extensions + num_straight_extensions + num_L2_extensions + num_B10_extensions);
 
     if(num_short_reductions > 2) {
@@ -12571,7 +12571,7 @@ contains_at_least_three_independent_short_reductions(int *max_pathlength_straigh
             for(j = i + 1; j < num_short_reductions - 1; j++)
                 if(!ISMARKED_V3(pentagons_short_reductions[j][0])
                         && !ISMARKED_V3(pentagons_short_reductions[j][1])) {
-                    mark_vertices_in_neighbourhood_bfs_v4(pentagons_short_reductions[j][0], 
+                    mark_vertices_in_neighbourhood_bfs_v4(pentagons_short_reductions[j][0],
                             pentagons_short_reductions[j][1], 3);
                     for(k = j + 1; k < num_short_reductions; k++)
                         if(!ISMARKED_V3(pentagons_short_reductions[k][0]) && !ISMARKED_V3(pentagons_short_reductions[k][1])
@@ -12585,7 +12585,7 @@ contains_at_least_three_independent_short_reductions(int *max_pathlength_straigh
                 }
         }
     }
-    
+
     return 0;
 }
 
@@ -12602,7 +12602,7 @@ contains_at_least_three_independent_short_reductions(int *max_pathlength_straigh
 static int
 has_5_vertices_on_distance_at_most_three(int v1, int v2) {
     RESETMARKS_V;
-    
+
     int queue[MAXN_DIST_3];
     int distances[MAXN_DIST_3];
     int queue_size = 0;
@@ -12610,12 +12610,12 @@ has_5_vertices_on_distance_at_most_three(int v1, int v2) {
     MARK_V(v1);
     distances[queue_size] = 0;
     queue_size++;
-    
+
     queue[queue_size] = v2;
     MARK_V(v2);
     distances[queue_size] = 0;
     queue_size++;
-    
+
     int i = 0;
     int j;
     EDGE *e;
@@ -12625,7 +12625,7 @@ has_5_vertices_on_distance_at_most_three(int v1, int v2) {
             if(!ISMARKED_V(e->end)) {
                 if(degree[e->end] == 5)
                     return 1;
-                
+
                 MARK_V(e->end);
                 if(distances[i] < 2) {
                     //Meaning e->end is at distance < 2
@@ -12638,7 +12638,7 @@ has_5_vertices_on_distance_at_most_three(int v1, int v2) {
         }
         i++;
     }
-    
+
     return 0;
 }
 
@@ -12654,7 +12654,7 @@ static int all_neighbours_are_6_vertices(int v) {
         if(degree[e->end] == 5)
             return 0;
         e = e->next;
-    }    
+    }
     return 1;
 }
 
@@ -12670,7 +12670,7 @@ static int will_remain_valid_ipr_reduction(int bent_zero_reduction_index) {
     for(i = 5; i < BENT_ZERO_SIZE; i++)
         if(!all_neighbours_are_6_vertices(bent_zero_extensions[bent_zero_reduction_index][i]))
             return 0;
-    
+
     return 1;
 }
 
@@ -12680,17 +12680,17 @@ static int will_remain_valid_ipr_reduction(int bent_zero_reduction_index) {
  * Returns 1 if at least one of the reductions from startedge_L1_reductions_parent
  * is still a valid straight reduction with length at most max_length.
  */
-static int contains_shorter_straight_reduction_ipr(EDGE *startedge_L1_reductions_parent[], 
+static int contains_shorter_straight_reduction_ipr(EDGE *startedge_L1_reductions_parent[],
         int num_L1_reductions_parent, int max_length) {
     int i;
     for(i = 0; i < num_L1_reductions_parent; i++)
         if(hasStraightIPR_given(startedge_L1_reductions_parent[i], max_length))
             return 1;
-    
+
     if(previous_rejector[nv] != NULL && hasStraightIPR_given(previous_rejector[nv], max_length)) {
         return 1;
     }
-    
+
     return 0;
 }
 
@@ -12705,11 +12705,11 @@ static int contains_L1_reduction_ipr(EDGE *startedge_L1_reductions_parent[], int
     for(i = 0; i < num_L1_reductions_parent; i++)
         if(has_short_straight_reduction_L1_ipr_modified(startedge_L1_reductions_parent[i]))
             return 1;
-    
+
     if(previous_rejector[nv] != NULL && has_short_straight_reduction_L1_ipr_modified(previous_rejector[nv])) {
-        return 1;    
+        return 1;
     }
-    
+
     return 0;
 }
 
@@ -12732,7 +12732,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
 
         return;
     }
-    
+
     DEBUGASSERT(nv < maxnv);
 
     if (nv == splitlevel)
@@ -12754,12 +12754,12 @@ scansimple_fuller_ipr(int nbtot, int nbop)
     if(startswitch && nv >= start_output && (nv >= splitlevel || splitcount == 0)) {
         got_one(nbtot,nbop);
     }
-    
+
 
 #ifdef PRE_FILTER_SIMPLE
     if (!(PRE_FILTER_SIMPLE)) return;
 #endif
-    
+
     int max_pathlength_straight = determine_max_pathlength_straight();
 
     /*
@@ -12772,7 +12772,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
     }
 
     /*
-     * Is necessary, since one cannot limit the pathlength to splitlevel 
+     * Is necessary, since one cannot limit the pathlength to splitlevel
      * in determine_max_pathlength_straight() if splitcount != 0.
      * This is because find_extensions_fuller_ipr() contains some optimizations
      * for short extensions. So the order in which extensions are found might
@@ -12785,8 +12785,8 @@ scansimple_fuller_ipr(int nbtot, int nbop)
     if(max_pathlength_straight > 3 && straight_length == 3) {
         DEBUGASSERT(num_bent_zero_extensions == 0);
         search_bent_zero_reductions_ipr();
-    }    
-    
+    }
+
     /* Trying to limit the max pathlength */
     num_L2_extensions = num_B10_extensions = 0;
     if(max_pathlength_straight > 4) {
@@ -12798,12 +12798,12 @@ scansimple_fuller_ipr(int nbtot, int nbop)
             }
             if(straight_length == 3 || num_bent_zero_extensions > 0 || num_L2_extensions > 0)
                 search_B10_reductions_ipr();
-            
+
             contains_indep_reductions = nv > LEVEL_THREE_INDEPENDENT && (num_L2_extensions > 0 || num_B10_extensions > 0)
                     && contains_at_least_three_independent_short_reductions(&max_pathlength_straight);
-                
+
         } //else: could also search for L2's and B10's for LA, but this doesn't really help much...
-        
+
         if(contains_indep_reductions) {
             //max_pathlength_straight = 3;
             //max_pathlength_straight = 4; //Since also L2 and B10
@@ -12819,15 +12819,15 @@ scansimple_fuller_ipr(int nbtot, int nbop)
             }
         }
     }
-    
+
     //This doesn't slow things down for small fullerenes, so ok!
     if(max_pathlength_straight > 5 &&
             (straight_length == 3 || num_bent_zero_extensions > 0)) {
         //Test how much L1 or B00 reductions there are where all vertices on
         //distance <= 3 are 6-vertices
-        //No matter what expansion is applied, these will still be a valid L3/B20/B11 
+        //No matter what expansion is applied, these will still be a valid L3/B20/B11
         //reduction after expansion
-        
+
         //Remark: for B00 not all vertices on distance <= 3 have to be 6-vertices
         //if the neighbours of a,b,c,a',b',c' are all 6-vertices it is sufficient!
         int contains_isolated_L1_or_B00_reductions = 0;
@@ -12913,23 +12913,23 @@ scansimple_fuller_ipr(int nbtot, int nbop)
     if(ext_bent_position == NULL) {
         fprintf(stderr, "Error: can't get enough memory\n");
         exit(1);
-    }    
+    }
     int *ext_bent_length = (int *) malloc(sizeof(int) * (max_bent_extensions * MAX_EXTENSIONS_SINGLE + 1));
     if(ext_bent_length == NULL) {
         fprintf(stderr, "Error: can't get enough memory\n");
         exit(1);
-    } 
+    }
     int *ext_bent_use_next = (int *) malloc(sizeof(int) * (max_bent_extensions * MAX_EXTENSIONS_SINGLE + 1));
     if(ext_bent_use_next == NULL) {
         fprintf(stderr, "Error: can't get enough memory\n");
         exit(1);
-    }    
+    }
 */
 
     int num_ext_L1, num_ext_bent_zero, num_ext_straight, num_ext_bent, xnbtot, xnbop;
     int i, j, test_canon;
     EDGE *work_edge;
-    
+
 
 #ifndef FIND_EXTENSIONS_SIMPLE_FULLER_IPR
 #define FIND_EXTENSIONS_SIMPLE_FULLER_IPR find_extensions_fuller_ipr
@@ -12941,7 +12941,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
             ext_straight, &num_ext_straight, ext_straight_length, ext_straight_use_next,
             //ext_bent_global, &num_ext_bent_global, ext_bent_position_global, ext_bent_length_global, ext_bent_use_next_global);
             NULL, &num_ext_bent_global, NULL, NULL, NULL);
-    
+
     num_ext_bent = num_ext_bent_global;
     //+1 to avoid arrays of size 0
 /*
@@ -12960,7 +12960,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
     if(ext_bent_position == NULL) {
         fprintf(stderr, "Error: can't get enough memory\n");
         exit(1);
-    }    
+    }
     int *ext_bent_length = (int *) malloc(sizeof(int) * (num_ext_bent + 1));
     if(ext_bent_length == NULL) {
         fprintf(stderr, "Error: can't get enough memory\n");
@@ -12971,19 +12971,19 @@ scansimple_fuller_ipr(int nbtot, int nbop)
         fprintf(stderr, "Error: can't get enough memory\n");
         exit(1);
     }
-    
+
     if(num_ext_bent > 0) {
         memcpy(ext_bent, ext_bent_global, sizeof(EDGE *) * num_ext_bent);
         memcpy(ext_bent_position, ext_bent_position_global, sizeof(int) * num_ext_bent);
         memcpy(ext_bent_length, ext_bent_length_global, sizeof(int) * num_ext_bent);
         memcpy(ext_bent_use_next, ext_bent_use_next_global, sizeof(int) * num_ext_bent);
     }
-    
+
     DEBUGASSERT(num_ext_L1 <= MAX_EXTENSIONS_SINGLE);
     DEBUGASSERT(num_ext_bent_zero <= MAX_EXTENSIONS_SINGLE);
     DEBUGASSERT(num_ext_straight <= max_straight_extensions * MAX_EXTENSIONS_SINGLE);
     DEBUGASSERT(num_ext_bent <= max_bent_extensions * MAX_EXTENSIONS_SINGLE);
-    
+
     EDGE *startedge_L1_reductions_parent[MAX_PREV_EXTENSIONS];
     int num_L1_reductions_parent = 0;
     if(straight_length == 3) {
@@ -12991,7 +12991,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
             startedge_L1_reductions_parent[i] = edge_list[straight_extensions[i][0]][straight_extensions[i][1]];
         num_L1_reductions_parent = num_straight_extensions;
     }
-    
+
     /* Perform straight expansions */
     int path[max_pathlength_straight + 1];
     int parallel_path[max_pathlength_straight + 1];
@@ -13016,7 +13016,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
         }
 
         extend_straight(ext_L1[i], path, parallel_path, 3, ext_L1_use_next[i]);
-        
+
         if(is_best_straight_reduction_ipr(edge_list[nv - 3][nv - 2],
                 edge_list[nv - 1][nv - 2], 3, ext_L1_use_next[i],
                 good_edges_next, &num_good_next, &can_edges_next, good_edges_prev, &num_good_prev, &can_edges_prev)) {
@@ -13025,7 +13025,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
                 test_canon = 0;
                 xnbtot = xnbop = 1;
             }
-            
+
             if(!test_canon || canon_edge_oriented(good_edges_next, num_good_next, can_edges_next,
                     good_edges_prev, num_good_prev, can_edges_prev, degree, numbering, &xnbtot, &xnbop)) {
                 if(nv < maxnv - 2) {
@@ -13046,7 +13046,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
 
                         num_straight_extensions++;
                     }
-                } 
+                }
                 scansimple_fuller_ipr(xnbtot, xnbop);
             }
 
@@ -13137,7 +13137,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
 
             extend_straight(ext_straight[i], path, parallel_path, ext_straight_length[i], ext_straight_use_next[i]);
 
-            if(!contains_shorter_straight_reduction_ipr(startedge_L1_reductions_parent, num_L1_reductions_parent, 
+            if(!contains_shorter_straight_reduction_ipr(startedge_L1_reductions_parent, num_L1_reductions_parent,
                         ext_straight_length[i] - 3)) {
                 if(is_best_straight_reduction_ipr(edge_list[nv - ext_straight_length[i]][nv - ext_straight_length[i] + 1],
                         edge_list[nv - 1][nv - 2], ext_straight_length[i], ext_straight_use_next[i],
@@ -13236,8 +13236,8 @@ scansimple_fuller_ipr(int nbtot, int nbop)
 
             extend_bent(ext_bent[i], path_bent, parallel_path_bent, ext_bent_position[i],
                     ext_bent_length[i], ext_bent_use_next[i]);
-            
-            if(!contains_shorter_straight_reduction_ipr(startedge_L1_reductions_parent, num_L1_reductions_parent, 
+
+            if(!contains_shorter_straight_reduction_ipr(startedge_L1_reductions_parent, num_L1_reductions_parent,
                             ext_bent_length[i] + 1)) {
                 if(is_best_bent_reduction(edge_list[nv - ext_bent_length[i] - 3][path_bent[0]], edge_list[nv - 1][path_bent[ext_bent_length[i] + 4]],
                         ext_bent_position[i], ext_bent_length[i], ext_bent_use_next[i],
@@ -13263,7 +13263,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
             reduce_bent(path_bent, parallel_path_bent, ext_bent_position[i], ext_bent_length[i]);
         }
     }
-    
+
     free(ext_bent);
     free(ext_bent_position);
     free(ext_bent_length);
@@ -13276,7 +13276,7 @@ scansimple_fuller_ipr(int nbtot, int nbop)
 /*
  * DFS algorithm to mark all vertices of a cap.
  */
-static void 
+static void
 mark_cap_vertices_recursion(int vertex) {
     DEBUGASSERT(ISMARKED_V2(vertex));
     EDGE *e, *ee;
@@ -13295,7 +13295,7 @@ mark_cap_vertices_recursion(int vertex) {
 /*
  * Returns 1 if vertex is the center of a 6-cluster of type IV, else returns 0.
  */
-static int 
+static int
 is_center_of_type4_patch(int vertex, int ismarked_cap) {
     DEBUGASSERT(degree[vertex] == 5 && (ISMARKED_V(vertex) || ISMARKED_V2(vertex) == ismarked_cap));
 
@@ -13331,7 +13331,7 @@ is_center_of_type4_patch(int vertex, int ismarked_cap) {
 
         if(e->start == start) {
             DEBUGASSERT(e->end == end);
-            
+
             DEBUGASSERT(counter == 5);
 
             return 1;
@@ -13347,7 +13347,7 @@ is_center_of_type4_patch(int vertex, int ismarked_cap) {
  * Returns 1 if the cap with the boundary defined by path contains a cap of
  * type IV, else returns 0.
  */
-static int 
+static int
 cap_contains_type4_patch(int path[], int path_length) {
     //First mark all vertices within the cap
     RESETMARKS_V;
@@ -13388,7 +13388,7 @@ cap_contains_type4_patch(int path[], int path_length) {
 /**
  * Returns 1 if an (23)^el (32)^m path was found starting from e, else returns 0.
  */
-static int 
+static int
 has_lm_path(EDGE *e, int el, int m, int path[], int *path_length, int outer_path[]) {
     DEBUGASSERT(el > 0);
     *path_length = 0;
@@ -13429,12 +13429,12 @@ has_lm_path(EDGE *e, int el, int m, int path[], int *path_length, int outer_path
             path[(*path_length)++] = e->end;
     }
     DEBUGASSERT(outer_path_length == el - 1);
-    
+
     outer_path[outer_path_length++] = e->invers->prev->end;
 
     if(m > 0) {
         DEBUGASSERT(*path_length == el + 1);
-        
+
         outer_path[outer_path_length++] = e->invers->prev->prev->end;
 
         //Go left
@@ -13444,7 +13444,7 @@ has_lm_path(EDGE *e, int el, int m, int path[], int *path_length, int outer_path
             return 0;
         else
             MARK_V(e->end);
-        
+
         path[(*path_length)++] = e->end;
 
         //Go m-1 times (right left)
@@ -13495,7 +13495,7 @@ has_lm_path(EDGE *e, int el, int m, int path[], int *path_length, int outer_path
  * Adds a ring of hexagons to the path which contains a bent.
  * Since there is a bent, there is only one possible extension.
  */
-static void 
+static void
 add_ring_bent(int path[], int path_length, int outer_path[], int bent_position) {
 
     DEBUGASSERT(nv + path_length <= maxnv);
@@ -13679,7 +13679,7 @@ add_ring_bent(int path[], int path_length, int outer_path[], int bent_position)
         replace_neighbour(outer_path[i], path[i - 1], nv + i - 1);
         replace_neighbour(outer_path[i], path[i], nv + i);
     }
-    
+
     //Update inverse edges and min
     EDGE *ee;
     for(i = 0; i < path_length; i++) {
@@ -13703,20 +13703,20 @@ add_ring_bent(int path[], int path_length, int outer_path[], int bent_position)
 /**
  * Is the inverse of add_ring_bent.
  */
-static void 
+static void
 remove_ring_bent(int path[], int path_length, int outer_path[], int bent_position) {
     //Restore
     nv -= path_length;
     ne -= 6 * path_length;
-    
+
     //No need to restore firstedges, they will be updated by replace_neighbour
-    
+
     /*
      * Also no need to restore edge_list since old values will still be valid:
      * 2 vertices which are not adjacent wont become adjacent after applying an
      * extension.
-     */    
-    
+     */
+
     //Restore edges
     restore_neighbour(path[0], nv, outer_path[0]);
 
@@ -13759,10 +13759,10 @@ remove_ring_bent(int path[], int path_length, int outer_path[], int bent_positio
         restore_neighbour(outer_path[i], nv + i - 1, path[i - 1]);
         restore_neighbour(outer_path[i], nv + i, path[i]);
     }
-    
+
     /* Update inverse edges and min */
     set_inverse_edges(path[0], outer_path[0]);
-    
+
     for(i = 1; i < bent_position; i++) {
         set_inverse_edges(path[i], outer_path[i - 1]);
         set_inverse_edges(path[i], outer_path[i]);
@@ -13778,7 +13778,7 @@ remove_ring_bent(int path[], int path_length, int outer_path[], int bent_positio
         DEBUGASSERT(i > 0);
         set_inverse_edges(path[i], outer_path[i]);
         set_inverse_edges(path[i], outer_path[(i + 1) % path_length]);
-    }    
+    }
 
     FREEEDGES(6 * path_length);
 }
@@ -13789,14 +13789,14 @@ remove_ring_bent(int path[], int path_length, int outer_path[], int bent_positio
  * Adds a ring of hexagons to the path which contains a bent.
  * Since there is a bent, there is only one possible extension.
  */
-static void 
+static void
 add_ring_bent_dispatch(int path[], int path_length, int outer_path[], int bent_position) {
-    
+
     if(nv + path_length > maxnv)
         return;
-    
+
     int nbtot, nbop, is_new_node;
-    
+
     int type;
     if(bent_position == 2)
         type = IRRED_CAP_2_8;
@@ -13804,9 +13804,9 @@ add_ring_bent_dispatch(int path[], int path_length, int outer_path[], int bent_p
         type = IRRED_CAP_8_2;
     else
         type = IRRED_CAP_5_5;
-    
+
     add_ring_bent(path, path_length, outer_path, bent_position);
-    
+
     int codelength = nv + ne + 1;
     unsigned char *can_form = (unsigned char *) malloc(sizeof(unsigned char) * codelength);
     if(can_form == NULL) {
@@ -13814,7 +13814,7 @@ add_ring_bent_dispatch(int path[], int path_length, int outer_path[], int bent_p
         exit(1);
     }
     canon_form(degree, numbering, &nbtot, &nbop, can_form);
-    splay_insert(&worklist, can_form, codelength, type, &is_new_node);    
+    splay_insert(&worklist, can_form, codelength, type, &is_new_node);
 
     if(is_new_node) { //i.e. is canon
 
@@ -13829,7 +13829,7 @@ add_ring_bent_dispatch(int path[], int path_length, int outer_path[], int bent_p
             }
             scansimple_fuller_ipr(nbtot, nbop);
         }
-        
+
         /*
          * Important: Also go above splitlevel even if splitcount != 0, since the same
          * irreducible ipr fullerene might also be generated in a different branch.
@@ -13847,7 +13847,7 @@ add_ring_bent_dispatch(int path[], int path_length, int outer_path[], int bent_p
 
 
     }
-    
+
     remove_ring_bent(path, path_length, outer_path, bent_position);
 
 }
@@ -13858,11 +13858,11 @@ add_ring_bent_dispatch(int path[], int path_length, int outer_path[], int bent_p
  * Adds a ring of hexagons to the path which contains no bent.
  * One cap is rotated in clockwise direction with a given offset.
  */
-static void 
+static void
 add_ring_no_bent(int path[], int path_length, int outer_path[], int offset) {
     DEBUGASSERT(nv + path_length <= maxnv);
     DEBUGASSERT(offset < path_length);
-    
+
     int i, j;
     EDGE *e;
     //First create the new vertices and edges
@@ -13928,9 +13928,9 @@ add_ring_no_bent(int path[], int path_length, int outer_path[], int offset) {
     for(i = 0; i < path_length; i++) {
         //replace_neighbour(outer_path[i], path[i], nv + ((i - 1 + path_length) % path_length));
         //replace_neighbour(outer_path[i], path[(i + 1) % path_length], nv + i);
-        
+
         replace_neighbour(outer_path[i], path[i], nv + ((i - 1 - offset + path_length) % path_length));
-        replace_neighbour(outer_path[i], path[(i + 1) % path_length], nv + ((i - offset + path_length) % path_length));        
+        replace_neighbour(outer_path[i], path[(i + 1) % path_length], nv + ((i - offset + path_length) % path_length));
     }
 
     //Update inverse edges and min
@@ -13961,19 +13961,19 @@ add_ring_no_bent(int path[], int path_length, int outer_path[], int offset) {
 /*
  * Is the inverse of add_ring_no_bent.
  */
-static void 
+static void
 remove_ring_no_bent(int path[], int path_length, int outer_path[], int offset) {
     //Restore
     nv -= path_length;
     ne -= 6 * path_length;
-    
+
     //No need to restore firstedges, they will be updated by replace_neighbour
-    
+
     /*
      * Also no need to restore edge_list since old values will still be valid:
      * 2 vertices which are not adjacent wont become adjacent after applying an
      * extension.
-     */    
+     */
 
     //Restore edges
     int i;
@@ -13988,7 +13988,7 @@ remove_ring_no_bent(int path[], int path_length, int outer_path[], int offset) {
         restore_neighbour(outer_path[i], nv + ((i - 1 - offset + path_length) % path_length), path[i]);
         restore_neighbour(outer_path[i], nv + ((i - offset + path_length) % path_length), path[(i + 1) % path_length]);
     }
-    
+
     /* Update inverse edges and min */
     for(i = 0; i < path_length; i++) {
         set_inverse_edges(path[i], outer_path[(i - 1 + path_length) % path_length]);
@@ -14005,15 +14005,15 @@ remove_ring_no_bent(int path[], int path_length, int outer_path[], int offset) {
  * Adds a ring of hexagons to a cap whose boundary contains no bent.
  * Max_offset determines how much the cap can be rotated at most.
  */
-static void 
+static void
 add_ring_no_bent_dispatch(int path[], int path_length, int outer_path[],
                 int max_offset) {
     if(nv + path_length > maxnv)
         return;
-    
+
     //Temp
     int type = path_length == 9 ? IRRED_CAP_9_0 : IRRED_CAP_10_0;
-    
+
     /*
      * The offset determines how much the cap is rotated.
      */
@@ -14021,7 +14021,7 @@ add_ring_no_bent_dispatch(int path[], int path_length, int outer_path[],
     for(i = 0; i < max_offset; i++) {
 
         add_ring_no_bent(path, path_length, outer_path, i);
-        
+
         int codelength = nv + ne + 1;
         unsigned char *can_form = (unsigned char *) malloc(sizeof(unsigned char) * codelength);
         if(can_form == NULL) {
@@ -14051,7 +14051,7 @@ add_ring_no_bent_dispatch(int path[], int path_length, int outer_path[],
              * So all modulo branches should generate all irreducible fullerenes,
              * otherwise one cannot be certainly a fullerene > splitlevel is canonical.
              * But of course only call scansimple_fuller_ipr() if splitcount == 0.
-             */            
+             */
 
             //Add more rings (i.e. recursion)
             int outer_path_new[path_length];
@@ -14063,7 +14063,7 @@ add_ring_no_bent_dispatch(int path[], int path_length, int outer_path[],
         }
 
         remove_ring_no_bent(path, path_length, outer_path, i);
-        
+
     }
 
 }
@@ -14079,7 +14079,7 @@ add_ring_no_bent_dispatch(int path[], int path_length, int outer_path[],
  * scansimple_fuller, then add a ring of degree 6 vertices to the nanotube
  * and recursively calls this method and repeats doing this until maxnv is
  * reached.
- * 
+ *
  * Important: it is assumed that this is the last construction method which
  * is called, since remove_ring_no_bent() is not called (but could easily do this).
  */
@@ -14097,8 +14097,8 @@ scansimple_and_add_ring() {
         if(nv < maxnv - 1) {
             straight_length = MAX_STRAIGHT_LENGTH + 1;
             num_bent_zero_extensions = 0;
-        }        
-        
+        }
+
         int nbtot, nbop;
         compute_group(degree, numbering, &nbtot, &nbop);
         scansimple_fuller(nbtot, nbop);
@@ -14165,7 +14165,7 @@ add_rings_irreducible_ipr() {
         int nbtot, nbop;
         compute_group(degree, numbering, &nbtot, &nbop);
         scansimple_fuller_ipr(nbtot, nbop);
-    } 
+    }
     //else
     //    return;
 
@@ -14175,8 +14175,8 @@ add_rings_irreducible_ipr() {
      * So all modulo branches should generate all irreducible fullerenes,
      * otherwise one cannot be certainly a fullerene > splitlevel is canonical.
      * But of course only call scansimple_fuller_ipr() if splitcount == 0.
-     */    
-    
+     */
+
     //Ring operation adds at least MIN_RINGSIZE_IPR 6-vertices
     if(nv + MIN_RINGSIZE_IPR <= maxnv) {
         EDGE *e, *ee;
@@ -14218,8 +14218,8 @@ add_rings_irreducible_ipr() {
                 }
 
                 if(has_lm_path(e, 10, 0, path, &path_length, outer_path)) {
-                    
-                    /* 
+
+                    /*
                      * Is necessary because there are multiple caps with a 10 0 boundary
                      * But the type 4 patch is the only irreducible one
                      */
@@ -14244,7 +14244,7 @@ add_rings_irreducible_ipr() {
         exit(1);
 
     }
-    
+
 }
 
 /***********************************************************************/
@@ -14550,24 +14550,24 @@ static void
 make_outputfiles_spirals() {
     sprintf(no_penta_spiral_filename, "No_pentagon_spiral_%d", maxnv);
     sprintf(no_spiral_filename, "No_spiral_%d", maxnv);
-    
+
     char strbuffer[50];
     if(startswitch) {
         sprintf(strbuffer, "_%d", start_output);
         strcat(no_penta_spiral_filename, strbuffer);
         strcat(no_spiral_filename, strbuffer);
     }
-    
+
     if(fulleriprswitch) {
         sprintf(strbuffer, "_ipr");
         strcat(no_penta_spiral_filename, strbuffer);
         strcat(no_spiral_filename, strbuffer);
     }
-    
+
     if(mod > 1) {
         sprintf(strbuffer, "_m_%d_%d", res, mod);
         strcat(no_penta_spiral_filename, strbuffer);
-        strcat(no_spiral_filename, strbuffer);        
+        strcat(no_spiral_filename, strbuffer);
     }
 }
 
@@ -14583,7 +14583,7 @@ simple_dispatch(void)
     startingsize = 12;
 
     CHECKRANGE(maxnv,"n",startingsize,MAXN);
-    
+
     if(startswitch) {
         if(start_output < startingsize || start_output > maxnv) {
             fprintf(stderr, ">E %s: start value is %d, but must be %d <= start < %d\n", cmdname, start_output, startingsize, maxnv);
@@ -14609,7 +14609,7 @@ simple_dispatch(void)
         hint = MIN(MAX(maxnv - 20, 12), MAX_SPLITLEVEL_IPR);
     else
         hint = MIN(MAX(maxnv - 20, 12), MAX_SPLITLEVEL);
-    
+
     //Important: it is assumed by other methods that splitlevel is < maxnv - 1
     //For fulleriprswitch and !startswitch it is assumed that splitlevel is < maxnv - 2
     initialize_splitting(startingsize, hint, maxnv - 3);
@@ -14647,7 +14647,7 @@ simple_dispatch(void)
             fprintf(stderr, "Error: can't get enough memory\n");
             exit(1);
         }
-        
+
         //nv + ne + 1
         int max_codelength = maxnv + 2 * (maxnv - 2)*3 + 1;
 
@@ -14683,12 +14683,12 @@ simple_dispatch(void)
                 scansimple_fuller_ipr(nbtot, nbop);
             }
         }
-        
+
         free(ext_bent_global);
         free(ext_bent_position_global);
         free(ext_bent_length_global);
         free(ext_bent_use_next_global);
-        
+
     } else {
 
         //nv = 12 and always <= splitlevel
@@ -14754,12 +14754,12 @@ unused_functions(void)
     (void) make_dual();
     (void) show_group(NULL,0,0);
     check_it(0,0);
-    
+
     (void) get_colour_prev(NULL);
     (void) get_colour_next(NULL);
     (void) canon(NULL, NULL, NULL,NULL);
     (void) canon_edge(NULL, 0, NULL, NULL, NULL, NULL);
-    
+
     print_embedded_graph();
     print_code(NULL, 0);
     write_planar_code_modified(NULL, 0);
@@ -14803,7 +14803,7 @@ MAIN(int argc, char *argv[])
     uswitch = TRUE;
     aswitch = gswitch = sswitch = FALSE;
 #endif
-    
+
     for (i = start_output; i <= maxnv; ++i)
     {
         ZEROBIG(nout[i]);
@@ -14836,16 +14836,16 @@ MAIN(int argc, char *argv[])
 #if CPUTIME
     times(&timestruct1);
 #endif
-    
+
     if(qswitch)
-        return 0;    
+        return 0;
 
     dosummary = 1;
 #ifdef SUMMARY
     nv = maxnv;
     SUMMARY();
 #endif
-    
+
     if(spiralcheck) {
         for(i = start_output; i <= maxnv; i++)
             if(number_without_pentagon_spiral[i] > 0)
@@ -14854,7 +14854,7 @@ MAIN(int argc, char *argv[])
             if(number_without_spiral[i] > 0)
                 fprintf(stderr, "Number of fullerenes with %d vertices which do not have a spiral: %llu\n", i, number_without_spiral[i]);
     }
-    
+
 #ifndef DONT_OUTPUT
     for(i = start_output; i <= maxnv; i++) {
         fprintf(stderr, "Number of fullerenes generated with %d vertices: ", i);
@@ -14862,7 +14862,7 @@ MAIN(int argc, char *argv[])
         fprintf(stderr, "\n");
     }
 #endif
-    
+
 #ifdef SPLITTEST
     PRINTBIG(msgfile,splitcases);
     fprintf(msgfile," splitting cases at level=%d",splitlevel);
@@ -14901,7 +14901,7 @@ MAIN(int argc, char *argv[])
 	fprintf(msgfile,"Suppressed ");
 	PRINTBIG(msgfile,nout_V);
 	fprintf(msgfile," with trivial group.\n");
-    }    
+    }
 #endif
 
 #ifdef STATS
@@ -14911,8 +14911,8 @@ MAIN(int argc, char *argv[])
     {
         SUMBIGS(total_numrooted,numrooted[i]);
         SUMBIGS(total_triv,ntriv[i]);
-    }    
-    
+    }
+
     for(i = start_output; i <= maxnv; i++) {
         fprintf(stderr, "Num rooted maps with %d vertices: ", i);
         PRINTBIG(msgfile, numrooted[i]);
diff --git a/src/fortran/schlegel.f b/src/fortran/schlegel.f
index aced299..716fb30 100644
--- a/src/fortran/schlegel.f
+++ b/src/fortran/schlegel.f
@@ -6,8 +6,8 @@
       use iso_c_binding
 C Produce points in 2D-space for Schlegel diagrams using the cone-
 C projection method and the perspective projection, or Tutte
-C embedding method and optimization to make it distant transitive. 
-C The fullerene is rotated first such that the desired point, edge 
+C embedding method and optimization to make it distant transitive.
+C The fullerene is rotated first such that the desired point, edge
 C or face is at the top. Euler angles are used for rotation.
       IMPLICIT REAL*8 (A-H,O-Z)
       REAL*8 layout2d
@@ -32,14 +32,14 @@ C     Parameter set for Program QMGA
       Data DPoint,Dedge/0.5d0,0.1d0/
 
 C     Prepare for Program QMGA
-      if(ifs.ge.2) then 
+      if(ifs.ge.2) then
        Open(unit=2,file=trim(filename)//"-2D.dat",form='formatted')
        Write(2,901) number_vertices,DPoint,Dedge
       endif
 
 C     Construct a graph object from the adjacency matrix
       g = new_fullerene_graph(Nmax,number_vertices,IDA)
-     
+
       dummy=' '
       satom='o'
       s5ring='^'
@@ -122,9 +122,9 @@ C   Search in 5-ring
           if(is2.eq.N5M(I,J)) n5hit=n5hit+1
           if(is3.eq.N5M(I,J)) n5hit=n5hit+1
           if(n5hit.eq.3) then
-            c(1)=cr5(1,I) 
-            c(2)=cr5(2,I) 
-            c(3)=cr5(3,I) 
+            c(1)=cr5(1,I)
+            c(2)=cr5(2,I)
+            c(3)=cr5(3,I)
             IR=I
             go to 150
           endif
@@ -137,11 +137,11 @@ C   Search in 6-ring
           if(is1.eq.N6M(I,J)) n6hit=n6hit+1
           if(is2.eq.N6M(I,J)) n6hit=n6hit+1
           if(is3.eq.N6M(I,J)) n6hit=n6hit+1
-          if(n6hit.eq.3) then 
-            c(1)=cr6(1,I) 
-            c(2)=cr6(2,I) 
+          if(n6hit.eq.3) then
+            c(1)=cr6(1,I)
+            c(2)=cr6(2,I)
             c(3)=cr6(3,I)
-            IR=N5R+I 
+            IR=N5R+I
             go to 150
           endif
         enddo
@@ -262,7 +262,7 @@ C   Now do the same with ring centers
       endif
       enddo
 
-C   Swap 
+C   Swap
       ival=IRing(imax)
       IRing(imax)=IRing(I)
       IRing(I)=ival
@@ -280,7 +280,7 @@ C rotation matrix
       if(iorig.eq.0) then
       ILast=IRing(NR)
 C   Get shortest distance
-      if(ILast.le.N5R) then 
+      if(ILast.le.N5R) then
       Symbol1='pentagon (P)'
       rminL=1.d10
       Do I=1,5
@@ -425,7 +425,7 @@ C   Print the sorted ring centers
 C   Choice between Schlegel projection or Tutte embedding
       If(ISchlegel-2) 10,20,30
 
-C   Algorithm 2: 
+C   Algorithm 2:
 C   Cone projection using the input angle
 C   Calculate distance of vertices from z-axis for projection
   20  app=rmin+Dist(3,1)
@@ -506,7 +506,7 @@ C   Print
       enddo
       go to 999
 
-C   Algorithm 1: 
+C   Algorithm 1:
 C   Perspective projection using the input distance
 C   Algorithm to produce symmetric Schlegel diagrams
 C   Smallest and largest ring z-coordinate
@@ -534,7 +534,7 @@ C   Atoms
       layout2d(2,IAT)=Dist(2,I)*Fac
       WRITE(IOUT,1028) IAT,layout2d(1,IAT),layout2d(2,IAT),
      1 IC3(IAT,1),IC3(IAT,2),IC3(IAT,3)
-      if(ifs.ge.2) 
+      if(ifs.ge.2)
      1 Write(2,902) IAT,layout2d(1,IAT),layout2d(2,IAT),
      1 IC3(IAT,1),IC3(IAT,2),IC3(IAT,3)
       enddo
@@ -572,7 +572,7 @@ C   Atoms
       iy=int(layout2d(2,I)*grids)
       iypos=iy+msrs2
       if(ixpos.le.0) ixpos=1
-      if(iypos.le.0) iypos=1 
+      if(iypos.le.0) iypos=1
       if(ixpos.gt.msrs) ixpos=msrs
       if(iypos.gt.msrs) iypos=msrs
       if(SRS(ixpos,2*iypos).eq.' ') then
@@ -589,7 +589,7 @@ C   Rings
       iy=int(RingS(2,I)*grids)
       iypos=iy+msrs2
       if(ixpos.le.0) ixpos=1
-      if(iypos.le.0) iypos=1 
+      if(iypos.le.0) iypos=1
       if(ixpos.gt.msrs) ixpos=msrs
       if(iypos.gt.msrs) iypos=msrs
       sring=s6ring
@@ -601,7 +601,7 @@ C   Rings
        endif
       enddo
 C   Print Schlegel picture
-      WRITE(IOUT,1024) msrs,2*msrs 
+      WRITE(IOUT,1024) msrs,2*msrs
       if(iflaga.ne.0.or.iflagr.gt.1) Write(6,1026) iflaga,iflagr
       do I=1,msrs
         WRITE(IOUT,1025) (SRS(I,J),J=1,2*msrs)
@@ -631,9 +631,9 @@ C   Search in 5-ring
          if(is2.eq.N5M(I,J)) n5hit=n5hit+1
          if(is3.eq.N5M(I,J)) n5hit=n5hit+1
           if(n5hit.eq.3) then
-           c(1)=cr5(1,I) 
-           c(2)=cr5(2,I) 
-           c(3)=cr5(3,I) 
+           c(1)=cr5(1,I)
+           c(2)=cr5(2,I)
+           c(3)=cr5(3,I)
            IR=I
            go to 250
           endif
@@ -647,10 +647,10 @@ C   Search in 6-ring
         if(is2.eq.N6M(I,J)) n6hit=n6hit+1
         if(is3.eq.N6M(I,J)) n6hit=n6hit+1
         if(n6hit.eq.3) then
-         c(1)=cr6(1,I) 
-         c(2)=cr6(2,I) 
+         c(1)=cr6(1,I)
+         c(2)=cr6(2,I)
          c(3)=cr6(3,I)
-         IR=N5R+I 
+         IR=N5R+I
          go to 250
         endif
        enddo
@@ -681,7 +681,7 @@ C  End of search
       endif
 
       if(ISchlegel.ge.7) then
-       WRITE(IOUT,1041) 
+       WRITE(IOUT,1041)
        maxl=0
       Do I=1,number_vertices
       Do J=I+1,number_vertices
@@ -718,7 +718,7 @@ C     Write to unit 2
        Do I=1,number_vertices
        WRITE(IOUT,1028) I,layout2d(1,I),layout2d(2,I),
      1  IC3(I,1),IC3(I,2),IC3(I,3)
-      if(ifs.eq.2.or.ifs.eq.3) 
+      if(ifs.eq.2.or.ifs.eq.3)
      1  Write(2,902) I,layout2d(1,I),layout2d(2,I),
      1  IC3(I,1),IC3(I,2),IC3(I,3)
        enddo
@@ -760,21 +760,21 @@ C  IOP=4: Kamada-Kawai embedding using the distance matrix MDist
         Write(Iout,1042) nhamcyc,(mhamfield(i),I=1,numberham)
         close(unit=8)
 
-C     Call format: draw_graph_with_path(filename, format (string), dimensions ((w,h) in cm), 
-C     edge_colour (x'rrggbb'), path_colour (x'rrggbb), vertex_colour (x'rrggbb), 
+C     Call format: draw_graph_with_path(filename, format (string), dimensions ((w,h) in cm),
+C     edge_colour (x'rrggbb'), path_colour (x'rrggbb), vertex_colour (x'rrggbb),
 C     edge_width (in mm), path_width (in mm), vertex_diameter (in mm) )
             call draw_graph_with_path(g,filename,"tex",(/15.d0,15.d0/),
-     1           x'270470',x'bb2510',x'458b00', 0.3d0, 1.0d0, 2.5d0, 
+     1           z'270470',z'bb2510',z'458b00', 0.3d0, 1.0d0, 2.5d0,
      2           numberham,mhamfield)
       else
-C     Call format: draw_graph(filename, format (string),ndual (0|1), dimensions ((w,h) in cm), 
-C     edge_colour (x'rrggbb'), vertex_colour (x'rrggbb), 
+C     Call format: draw_graph(filename, format (string),ndual (0|1), dimensions ((w,h) in cm),
+C     edge_colour (x'rrggbb'), vertex_colour (x'rrggbb),
 C     edge_width (in mm), vertex_diameter (in mm) )
          call draw_graph(g,filename,"tex",ndual, nlabel_vertices,
      1     (/15.d0,15.d0/), x'274070', x'458b00', 0.3d0, 2.5d0)
       endif
 c Output to POVRay raytracer. Commented out currently.
-c$$$      call draw_graph(g,filename, "pov",0, (/10.d0,10.d0/), 
+c$$$      call draw_graph(g,filename, "pov",0, (/10.d0,10.d0/),
 c$$$     1                x'bb7755', x'8899bb', 0.3d0, .8d0)
       endif
       call delete_fullerene_graph(g)
@@ -863,7 +863,7 @@ c$$$     1                x'bb7755', x'8899bb', 0.3d0, .8d0)
      1 ' not identical to number of vertices ',I5,' ===> RETURN')
  1036 Format(1X,'Calculating Tutte-embedding and shift to barycenter')
  1037 FORMAT(1X,'Fullerene graph deleted',/,' Graph coordinates:',
-     1 /,'  Atom       X            Y        N1   N2   N3') 
+     1 /,'  Atom       X            Y        N1   N2   N3')
  1038 Format(1X,'5-Ring center 'I4,' defined by atoms ',3(I4,' , '),
      1 I4,' and ',I4,' chosen for Schlegel alignment.',
      2 /1X,' Coordinates of ring center: X= ',
@@ -896,7 +896,7 @@ c$$$     1                x'bb7755', x'8899bb', 0.3d0, .8d0)
  1002 Format(3(' |',F12.6,1X),' |')
       Return
       END
- 
+
       SUBROUTINE Rotmat(Iout,Rot,vec)
       use config
       IMPLICIT REAL*8 (A-H,O-Z)
@@ -944,7 +944,7 @@ C     Now checking on the original vector
       enddo
       endif
       Write(Iout,1001) betaw,alphaw,anorm,vec1(3)
-      Write(Iout,1002) 
+      Write(Iout,1002)
       Write(Iout,1003) ((Rot(I,J),J=1,3),I=1,3)
  1000 Format(1X,'WARNING: Vector should be unit vector but is ',F12.6)
  1001 Format(1X,'Rotate around y-axis by ',F12.6,' degrees, then'
@@ -954,7 +954,7 @@ C     Now checking on the original vector
  1003 Format(3(' |',F12.6,1X),' |')
       Return
       END
- 
+
       SUBROUTINE Rotate(Rot,vec,vec1)
       IMPLICIT REAL*8 (A-H,O-Z)
       DIMENSION Rot(3,3),vec(3),vec1(3)
@@ -987,7 +987,7 @@ C     simple spring embedding
          endif
       enddo
       enddo
-C     total energy  
+C     total energy
       fc=f*ehook
       endif
 
@@ -1032,7 +1032,7 @@ C     Pisanski-Plestenjak-Graovac algorithm
         endif
       enddo
       enddo
-C     total energy  
+C     total energy
       fc=ehook
       endif
 
@@ -1054,7 +1054,7 @@ C     Kamada-Kawai embedding
           ehook=ehook+((ratom-RAA*DD)/DD)**2
       enddo
       enddo
-C     total energy  
+C     total energy
       fc=f*ehook
       endif
 
@@ -1096,7 +1096,7 @@ C     Fix outer vertices
         endif
       enddo
       endif
-  
+
 C     Repulsive Coulomb
       if(IOP.eq.2) then
       Do I=1,2*number_vertices,2
@@ -1197,7 +1197,7 @@ C   Determine min distance of outer ring
 C   Scale
       do i=1,M
        r=dsqrt(Dist(1,I)**2+Dist(2,I)**2)
-       scale=1.d0+.5d0*fs*(rmin-r)/rmin      
+       scale=1.d0+.5d0*fs*(rmin-r)/rmin
        Dist(1,I)=Dist(1,I)*scale
        Dist(2,I)=Dist(2,I)*scale
       enddo
@@ -1215,11 +1215,11 @@ c     evenly.
       integer is(6), depths(M), d_max,i
       real*8 Dist(2,Nmax), c(2), radius, dr, d
       type(c_ptr)::g
-      Write(Iout,1000) 
+      Write(Iout,1000)
 
       call vertex_depth(g,IS,lring,depths,d_max)
 
-C     Calculate barycentre 
+C     Calculate barycentre
       c = (/0,0/)
       do i=1,M
          c(1) = c(1) + Dist(1,i)*(1.d0/M)
@@ -1243,7 +1243,7 @@ C   Scale
             Dist(2,I)=(Dist(2,I)-c(2))*radius/d+c(2)
          endif
       enddo
- 1000 Format(1X,'Graph layout from Tutte-embedding angles, linearly 
+ 1000 Format(1X,'Graph layout from Tutte-embedding angles, linearly
      1           distributed raii.')
       return
       END
